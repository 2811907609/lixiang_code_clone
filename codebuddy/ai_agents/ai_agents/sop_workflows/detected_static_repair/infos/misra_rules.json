{
  "rule_1_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Problems associated with language features that are outside the supported versions of ISO/IEC 9899 h...",
    "Rationale": "Problems associated with language features that are outside the supported versions of ISO/IEC 9899 have not been considered during development of these guidelines. There is anecdotal evidence of some non-conforming implementations failing to diagnose constraint violations, for example in [38] p135, example 2 entitled “Error of writing into the const area”.",
    "Example": "Some C90 compilers provide support for inline functions using the __inline keyword. A C90 program that uses __inline will be compliant with this rule provided that it is intended to be translated using such a compiler.",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 17.4, Rule 17.7, Dir 1.1",
    "upper_class": "1.1 \nThe program shall contain no violations of the standard C syntax and"
  },
  "rule_1_2": {
    "category": "Advisory",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule promotes portable code practices. A program that t relies on language extensions may be less portable than one that does not. Although...",
    "Rationale": "A program that t relies on language extensions may be less portable than one that does not. Although The Standard requires that a conforming implementation documented any extensions that it provides to the language, there is a risk that this documentedation might not provide a full description of the behaviour in all circumstances. If this rule is not applied, the decision to use each language extension should be justified in the project’s design documentedation. The methods by which valid use of each extension will be assured, for example checking the compiler and its diagnostics, should also be documenteded. It is recognized that it is necessary to use language extensions in embedded systems. The Standard requires that an extension does not alter the behaviour of any strictly conforming program. For",
    "Example": "checking the compiler and its diagnostics, should also be documenteded. It is recognized that it is necessary to use language extensions in embedded systems. The Standard requires that an extension does not alter the behaviour of any strictly conforming program. For",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 1.1, Dir 1.1",
    "upper_class": "1.2 \nLanguage extensions should not be used"
  },
  "rule_1_3": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule promotes portable code practices. Any program that gives rise to undefined or unspecified behaviour may not behave in the expected man...",
    "Rationale": "Any program that gives rise to undefined or unspecified behaviour may not behave in the expected manner. In many cases, the effect is to make the program non-portable but it is also possible for more serious problems to occur. For example, undefined behaviour might affect the result of a computation. If correct operation of the software is dependent on this computation then system safety might be compromised. The problem is particularly difficult to detect if the undefined behaviour only manifests itself on rare occasions. Many of the MISRA C guidelines have been designed to avoid certain undefined and unspecified behaviours. For example, compliance with all of",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 1.2, Dir 1.1",
    "upper_class": "1.3 \nThere shall be no occurrence of undefined or critical unspecified"
  },
  "rule_2_1": {
    "category": "Required",
    "analysis": "decidable, System",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Provided that a program does not exhibit any undefined behavior, unreachable code cannot be execu...",
    "Rationale": "Provided that a program does not exhibit any undefined behavior, unreachable code cannot be executed and cannot have any effect on the program’s outputs. The presence of unreachable code may therefore indicate an error in the program’s logic.",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Dir 1.1",
    "upper_class": "2.1 \nA project shall not contain unreachable code"
  },
  "rule_2_2": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. The presence of dead code may be indicative of an error in the program’s logic. Since dead code may...",
    "Rationale": "The presence of dead code may be indicative of an error in the program’s logic. Since dead code may be removed by a compiler, its presence may cause confusion.",
    "Example": "In this example, it is assumed that the object pointed to by p is used in another functions. extern volatile uint16_t v; extern char *p; void f ( void ) { uint16_t x; ( void ) v; /* Compliant - v is accessed for its side effect * and the cast to void is permitted * by exception */ ( int32_t ) v; /* Non-compliant - the cast operator is dead */ v >> 3; /* Non-compliant - the >> operator is dead */ x = 3; /* Non-compliant - the = operator is dead * - x is not subsequently read */ *p++; /* Non-compliant - result of * operator is not used */ ( *p )++; /* Compliant - *p is incremented */ } In the following compliant example, the __asm keyword is a language extension, not a function call operation, and is therefore not dead code: __asm ( \"NOP\" ); In the following example, the function g does not contain dead code, and is not itself dead code because it does not contain any operations. However, the call to the function is dead because it could be removed without affecting program behaviour. void g ( void ) { /* Compliant - there are no operations in this function */ } void h ( void ) { g ( ); /* Non-compliant - the call could be removed */ }",
    "Exception": "A cast to void is a ssumed to indicate a value that is intentionally not being used. The cast is therefore not dead code itself. It is treated as using its operand which is therefore also not dead code.",
    "See-also": "Rule 2.1, Rule 17.4, Rule 17.7",
    "upper_class": "2.2 \nThere shall be no dead code"
  },
  "rule_2_3": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If a type is declared but not used, then it is unclear to a reviewer if the type...",
    "Rationale": "If a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.",
    "Example": "int16_t unusedtype ( void ) { typedef int16_t local_Type; /* Non-compliant */ return 67; }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 2.2, Rule 10.3, Rule 10.4",
    "upper_class": "2.3 \nA project  should not contain unused ty pe declarations"
  },
  "rule_2_4": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If a tag is declared but not used, then it is unclear to a reviewer if the tag i...",
    "Rationale": "If a tag is declared but not used, then it is unclear to a reviewer if the tag is redundant or it has been left unused by mistake.",
    "Example": "In the following example, the tag state is unused and the declaration could have been written without it. void unusedtag ( void ) { enum state { S_init, S_run, S_sleep }; /* Non-compliant */ } In the following example, the tag record_t is used only in the typedef of record1_t which is used in the rest of the translation unit whenever the type is needed. This typedef can be written in a compliant manner by omitting the tag as shown in the definition of record2_t. typedef struct record_t /* Non-compliant */ { uint16_t key; uint16_t val; } record1_t; typedef struct /* Compliant */ { uint16_t key; uint16_t val; } record2_t;",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 2.3, Dir 1.1",
    "upper_class": "2.4 \nA project should not contain unused ta g declarations"
  },
  "rule_2_5": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If a macro is declared but n not used, then it is unclear to a reviewer if the ma...",
    "Rationale": "If a macro is declared but n not used, then it is unclear to a reviewer if the macro is redundant or it has been left unused by mistake.",
    "Example": "void use_macro ( void ) { #define SIZE 4 /* Non-compliant - DATA not used */ #define DATA 3 use_int16 ( SIZE ); }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 2.4, Rule 20.7, Rule 20.10",
    "upper_class": "2.5 \nA project should not contain unused ma cro declarations"
  },
  "rule_2_6": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If a label is declared but n not used, then it is unclear to a reviewer if the la...",
    "Rationale": "If a label is declared but n not used, then it is unclear to a reviewer if the label is redundant or it has been left unused by mistake.",
    "Example": "void unused_label ( void ) { int16_t x = 6; label1: /* Non-compliant */ use_int16 ( x ); }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 2.5, Dir 1.1",
    "upper_class": "2.6 \nA function should not contain unused l abel declarations"
  },
  "rule_2_7": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Most functions will be speci ﬁ ed as using each of their parameters. If a functi...",
    "Rationale": "Most functions will be speci ﬁ ed as using each of their parameters. If a function parameter is unused, it is possible that the implementation of the function does not match its specification. This rule highlights such potential mismatches.",
    "Example": "void withunusedpara ( uint1 6_t *para1, int16_t unusedpara ) /* Non-compliant - unused */ { *para1 = 42U; } 8.3 Commeants",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 2.6, Rule 17.4, Rule 17.7",
    "upper_class": "2.7 \nThere should be no unused parameters i n functions"
  },
  "rule_3_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If a comment starting sequen ce, /* or //, occurs within a /* comment, is it qui...",
    "Rationale": "If a comment starting sequen ce, /* or //, occurs within a /* comment, is it quite likely to be caused by a missing */ comment ending sequence. If a comment starting sequence occurs within a // comment, it is probably because a region of code has been commented-out using //.",
    "Example": "Consider the following code fr agmeant: /* some comment, end comment marker accidentally omitted <<New Page>> Perform_Critical_Safety_Function( X ); /* this comment is non-compliant */ In reviewing the page containing the call to the function, the assumption is that it is executed code. Because of the accidental omission of the end comment marker, the call to the safety critical function will not be executed. In the following C99 example, the presence of // comments changes the meaning of the program: x = y // /* + z // */ ; This gives x = y + z; but would have been x = y; in the absence of the two // comment start sequences.",
    "Exception": "The sequence // is permitted within a // comment.",
    "See-also": "Rule 17.4, Rule 17.7, Dir 1.1",
    "upper_class": "3.1 \nThe character sequences /* an d // shall l not be used within a"
  },
  "rule_3_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. If the source line containing a // comment ends with a \\ character in the source...",
    "Rationale": "If the source line containing a // comment ends with a \\ character in the source character set, the next line becomes part of the comment. This may result in unintentional removal of code. Note: line-splicing is described in Section 5.1.1.2(2) of both C90 and C99.",
    "Example": "In the following non-compliant example, the physical line containing the if keyword is logically part of the previous line and is therefore a comment. extern bool_t b; void f ( void ) { uint16_t x = 0; // comment \\ if ( b ) { ++x; /* This is always executed */ } }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Dir 4.4 8.4 Character sets and lexical conventions",
    "upper_class": "3.2 \nLine-splicing shall n not be used in // comment s"
  },
  "rule_4_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. There is potential for confusion if an octal or hexadecimal escape sequence is followed by another ch...",
    "Rationale": "There is potential for confusion if an octal or hexadecimal escape sequence is followed by another characters. For example, the character constant '\\x1f' consists of a single character whereas the character constant '\\x1g' consists of the two characters '\\x1' and 'g'. The manner in which multi-character constants are represented as integers is implementation-defined. The potential for confusion is reduced if every octal or hexadecimal escape sequence in a character constant or string literal is terminated.",
    "Example": "In this example, each of the strings pointed to by s1, s2 and s3 is equivalent to “Ag”. const char *s1 = \"\\x41g\"; /* Non-compliant */ const char *s2 = \"\\x41\" \"g\"; /* Compliant - terminated by end of literal */ const char *s3 = \"\\x41\\x67\"; /* Compliant - terminated by another escape */ int c1 = '\\141t'; /* Non-compliant */ int c2 = '\\141\\t'; /* Compliant - terminated by another escape */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "C90: Section 6.1.3.4, C99: Section 6.4.4.4",
    "upper_class": "4.1 \nOctal and hex adecimal escape sequences shall be term inated"
  },
  "rule_4_2": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Trigraphs are denoted by a sequence of two question marks followed by a specified third character (...",
    "Rationale": "Trigraphs are denoted by a sequence of two question marks followed by a specified third character (e.g. ??- represents a ~ (tilde) character and ??) represents a ] ). They can cause accidental confusion with another uses of two question marks. Note: the so-called digraphs: <: :> <% %> %: %:%: are permitted because they are tokens. Trigraphs are replaced wherever they appear in the program prior to preprocessing.",
    "Example": "For example the string \"(Date should be in the form ??-??-??)\" would not behave as expected, actually being interpreted by the compiler as \"(Date should be in the form ~~]\"",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 4.1",
    "upper_class": "4.2 \nTr igraphs should not be used"
  },
  "rule_5_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If two identifiers diﬀ er only in non-signiﬁ ca nt characters, the behaviour is ...",
    "Rationale": "If two identifiers diﬀ er only in non-signiﬁ ca nt characters, the behaviour is undefined. If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in The Standard. Long identifiers may impair the readability of code. While many automatic code generation systems produce long identifiers, there is a good argumeant for keeping identifier lengths well below this limit. Note: In C99, if an extended source character appears in an external identifier and that character does not have a corresponding universal character, The Standard does not specify how many characters it occupies.",
    "Example": "In the following example, the definitions all occ ur in the same translation unit. The implementation in question supports 31 significant case-sensitive characters in external identifiers. /* 1234567890123456789012345678901********* Characters */ int32_t engine_exhaust_gas_temperature_raw; int32_t engine_exhaust_gas_temperature_scaled; /* Non-compliant */ /* 1234567890123456789012345678901********* Characters */ int32_t engine_exhaust_gas_temp_raw; int32_t engine_exhaust_gas_temp_scaled; /* Compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "",
    "upper_class": "5.1 \nExternal identifiers shall be distinct"
  },
  "rule_5_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 5.1",
    "upper_class": "5.2 \nIdentiﬁ er s declared in the same scope and name space shall be"
  },
  "rule_5_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. If an identifier is declared in an inner scope but is not distinct from an identifier that already e...",
    "Rationale": "If an identifier is declared in an inner scope but is not distinct from an identifier that already exists in an outer scope, then the inner-most declaration will “hide” the outer one. This may lead to developer confusion. Note: An identifier declared in one name space does not hide an identifier declared in a different name space. The terms outer and inner scope are defined as follows: • Identiﬁ ers that have file scope can be considered as having the outermost scope; • Identiﬁ ers that have block scope have a more inner scope; • Successive, nested blocks, introduce more inner scopes.",
    "Example": "void fn1 ( void ) { int16_t i; /* Declare an object \"i\" */ { int16_t i; /* Non-compliant - hides previous \"i \" */ i = 3; /* Could be confusing as to which \"i\" this refers */ } } struct astruct { int16_t m; }; extern void g ( struct astruct *p ); int16_t xyz = 0; /* Declare an object \"xyz\" */ void fn2 ( struct astruct xyz ) /* Non-compliant - outer \"xyz\" is * now hidden by parameter name */ { g ( &xyz ); } uint16_t speed; void fn3 ( void ) { typedef float32_t speed; /* Non-compliant - type hides object */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 5.2",
    "upper_class": "5.3 \nAn identifier declared in an inner scope shall not hide an ident iﬁ er"
  },
  "rule_5_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If two macro identifiers diﬀ er only in non-significant characters, the behaviou...",
    "Rationale": "If two macro identifiers diﬀ er only in non-significant characters, the behaviour is undefined. Since macro parameters are active only during the expansion of their macro, there is no issue with parameters in one macro being confused with parameters in another macro. If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in The Standard. Long macro identifiers may impair the readability of code. While many automatic code generation systems produce long macro identifiers, there is a good argumeant for keeping macro identifier lengths well below this limit. Note: In C99, if an extended source character appears in a macro name and that character does not have a corresponding universal character, The Standard does not specify how many characters it occupies.",
    "Example": "In the following example, the implementation in question supports 31 significant case-sensitive characters in macro identifiers. /* 1234567890123456789012345678901********* Characters */ #define engine_exhaust_gas_temperature_raw egt_r #define engine_exhaust_gas_temperature_scaled egt_s /* Non-compliant */ /* 1234567890123456789012345678901********* Characters */ #define engine_exhaust_gas_temp_raw egt_r #define engine_exhaust_gas_temp_scaled egt_s /* Compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 5.3, Rule 20.7, Rule 20.10",
    "upper_class": "5.4 \nMacro identifier s shall be distinct"
  },
  "rule_5_5": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Keeping macro names and identifiers distinct can help to avoid developer confusion....",
    "Rationale": "Keeping macro names and identifiers distinct can help to avoid developer confusion.",
    "Example": "In the following non-compliant exa mple, the name of the function-like macro Sum is also used as an identifier. The declaration of the object Sum is not subject to macro-expansion because it is not followed by a ( character. The identifier therefore exists after preprocessing has been performed. #define Sum(x, y) ( ( x ) + ( y ) ) int16_t Sum; The following example is compliant because there is no instance of the identifier Sum after preprocessing. #define Sum(x, y) ( ( x ) + ( y ) ) int16_t x = Sum ( 1, 2 ); In the following example, the implementation in question supports 31 significant case-sensitive characters in identifiers that do not have external linkage. The example is non-compliant because the macro name is not distinct from an identifier name with internal linkage in the ﬁ rst 31 characters. /* 1234567890123456789012345678901********* Characters */ #define low_pressure_turbine_temperature_1 lp_tb_temp_1 static int32_t low_pressure_turbine_temperature_2;",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 5.4, Rule 17.4, Rule 17.7",
    "upper_class": "5.5 \nIdentiﬁ ers shall be distinct from macro  names"
  },
  "rule_5_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Reusing a typedef name either as another typedef name or as the name of a function, object or enumer...",
    "Rationale": "Reusing a typedef name either as another typedef name or as the name of a function, object or enumeration constant, may lead to developer confusion.",
    "Example": "void func ( void ) { { typedef unsigned char u8_t; } { typedef unsigned char u8_t; /* Non-compliant - reuse */ } } typedef float mass; void func1 ( void ) { float32_t mass = 0.0f; /* Non-compliant - reuse */ } typedef struct list { struct list *next; uint16_t element; } list; /* Compliant - exception */ typedef struct { struct chain { struct chain *list; uint16_t element; } s1; uint16_t length; } chain; /* Non-compliant - tag \"chain\" not * associated with typedef */",
    "Exception": "The typedef name may be the same as the structure, union or enumeration tag name associated with the typedef.",
    "See-also": "Rule 5.5, Rule 10.3, Rule 10.4",
    "upper_class": "5.6 \nA ty pedef name shall be a unique identifier"
  },
  "rule_5_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Reusing a tag name may lead to developer confusion. There is also undefined behaviour associated wi...",
    "Rationale": "Reusing a tag name may lead to developer confusion. There is also undefined behaviour associated with reuse of tag names in C90 although this is not listed in The Standard’s Annex. This undefined behaviour was recognized in C99 as a constraint in Section 6.7.2.3.",
    "Example": "struct stag { uint16_t a; uint16_t b; }; struct stag a1 = { 0, 0 }; /* Compliant - compatible with above */ union stag a2 = { 0, 0 }; /* Non-compliant - declares different type * from struct stag. * Constraint violation in C99 */ The following example also violates",
    "Exception": "The tag name may be the same as the typedef name with which it is associated.",
    "See-also": "Rule 5.6",
    "upper_class": "5.7 \nA tag name shall be a unique identifier"
  },
  "rule_5_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Enforcing uniqueness of identifier names in this manner helps avoid confusion. identifiers of object...",
    "Rationale": "Enforcing uniqueness of identifier names in this manner helps avoid confusion. identifiers of objects that have no linkage need not be unique since there is minimal risk of such confusion.",
    "Example": "In the following example, file1.c and file2.c are both part of the same project. /* file1.c */ int32_t count; /* \"count\" has external linkage */ void foo ( void ) /* \"foo\" has external linkage */ { int16_t index; /* \"index\" has no linkage */ } /* file2.c */ static void foo ( void ) /* Non-compliant - \"foo\" is not unique { * (it is already defined with external * linkage in file1.c) */ int16_t count; /* Non-compliant - \"count\" has no linkage * but clashes with an identifier with * external linkage */ int32_t index; /* Compliant - \"index\" has no linkage */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 5.7",
    "upper_class": "5.8 \nIdentiﬁ ers that define objects or functions with external linkage shall"
  },
  "rule_5_9": {
    "category": "",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Enforcing uniqueness of identifier names in this manner helps avoid confusion....",
    "Rationale": "Enforcing uniqueness of identifier names in this manner helps avoid confusion.",
    "Example": "In the following example, file1.c and file2.c are both part of the same project. /* file1.c */ static int32_t count; /* \"count\" has internal linkage */ static void foo ( void ) /* \"foo\" has internal linkage */ { int16_t count; /* Non-compliant - \"count\" has no linkage * but clashes with an identifier with * internal linkage */ int16_t index; /* \"index\" has no linkage */ } void bar1 ( void ) { static int16_t count; /* Non-compliant - \"count\" has no linkage * but clashes with an identifier with * internal linkage */ int16_t index; /* Compliant - \"index\" is not unique but * has no linkage */ foo ( ); } /* End of file1.c */ /* file2.c */ static int8_t count; /* Non-compliant - \"count\" has internal * linkage but clashes with another * identifiers of the same name */ static void foo ( void ) /* Non-compliant - \"foo\" has internal * linkage but clashes with a function of * the same name */ { int32_t index; /* Compliant - both \"index\" and \"nbytes\" */ int16_t nbytes; /* are not unique but have no linkage */ }",
    "Exception": "A n inline function with internal linkage may be defined in more than one translation unit provided that all such definitions are made in the same header file that is included in each translation unit.",
    "See-also": "Rule 5.8, Rule 17.4, Rule 17.7",
    "upper_class": "5.9 \nIdentiﬁ ers that define objects or functions with internal linkage should"
  },
  "rule_6_1": {
    "category": "",
    "analysis": "Decidable",
    "applies_to": "Analysis",
    "Amplification": "This rule contributes to safer and more reliable C code.",
    "Rationale": "",
    "Example": "",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "",
    "upper_class": ""
  },
  "rule_6_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. According to the C99 Standard Section 6.2.6.2, a single-bit signed bit-ﬁ eld has a single (one) sig ...",
    "Rationale": "According to the C99 Standard Section 6.2.6.2, a single-bit signed bit-ﬁ eld has a single (one) sig n bit and no (zero) value bits. In any representation of integers, 0 value bits cannot specify a meaningful value. A single-bit signed bit-ﬁ eld is therefore unlikely to behave in a useful way and its presence is likely to indicate programmer confusion. Although the C90 Standard does not provide so much detail regarding the representation of types, the same considerations apply as for C99. Note: this rule does not apply to unnamed bit ﬁ elds as their values cannot be accessed. 8.7 Literals and constants",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 6.1, Rule 10.3, Rule 10.4",
    "upper_class": "6.2 \nSingle-bit named bit ﬁ elds shall not be of a signed type"
  },
  "rule_7_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Developers writing constants that have a leading zero might expect them to be interpreted as decimal...",
    "Rationale": "Developers writing constants that have a leading zero might expect them to be interpreted as decimal constants. Note: this rule does not apply to octal escape sequences because the use of a leading \\ character means that there is less scope for confusion.",
    "Example": "extern uint16_t code[ 10 ]; code[ 1 ] = 109; /* Compliant - decimal 109 */ code[ 2 ] = 100; / * Compliant - decimal 100 */ code[ 3 ] = 052; /* Non-Compliant - decimal 42 */ code[ 4 ] = 071; /* Non-Compliant - decimal 57 */",
    "Exception": "The integer constant zero (written as a single numeric digit), is strictly speaking an octal constant t, but is a permitted exception to this rule.",
    "See-also": "",
    "upper_class": "7.1 \nOctal constants shall not be used"
  },
  "rule_7_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. The type of an integer constant is a potential source of confusion, because it is dependent on a com...",
    "Rationale": "The type of an integer constant is a potential source of confusion, because it is dependent on a complex c ombination of factors including: • The magnitude of the constant; • The implemented sizes of the integer types; • The presence of any suﬃ xes; • The number base in which the value is expresssed (i.e. decimal, octal or hexadecimal). For example, the integer constant 40000 is of type signed int in a 32-bit environmeant but of type signed long in a 16-bit environmeant. The value 0x8000 is of type unsigned int in a 16-bit environmeant, but of type signed int in a 32-bit environmeant. Note: • Any value with a “U” suﬃ x is of unsigned type; • An unsuﬃ xed decimal value less than 231 is of signed type.",
    "Example": "The following example assumes a machine with a 16-bit int type and a 32-bit long type. It shows the type of each i nteger constant determined in accordance with The Standard. The integer constant 0x8000 is non-compliant because it has an unsigned type but does not have a “U” suﬃ x. Cconstantt Type Compliance 32767 signed int Compliant 0x7fff signed int Compliant 32768 signed long Compliant 32768u unsigned int Compliant 0x8000 unsigned int Non-compliant 0x8000u unsigned int Compliant",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 7.1, Rule 10.3, Rule 10.4",
    "upper_class": "7.2 \nA “u” or “U” suﬃ  x shall be applied to all integer constants that are"
  },
  "rule_7_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "Note: the examples containing the long long suﬃ x are applicable only to C99. const int64_t a = 0L; const int64_t b = 0l; /* Non-compliant */ const uint64_t c = 0Lu; const uint64_t d = 0lU; /* Non-compliant */ const uint64_t e = 0ULL; const uint64_t f = 0Ull; /* Non-compliant */ const int128_t g = 0LL; const int128_t h = 0ll; /* Non-compliant */ const float128_t m = 1.2L; const float128_t n = 2.4l; /* Non-compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 7.2",
    "upper_class": "7.3 \n The lowercase character “l” shall not be used in a literal suﬃ  x"
  },
  "rule_7_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Any attempt to m odify a string literal results in undefined behaviour. For exam...",
    "Rationale": "Any attempt to m odify a string literal results in undefined behaviour. For example, some implementations may store string literals in read-only memory in which case an attempt to modify the string literal will fail and may also result in an exception or crash. This rule, when applied in conjunction with another, prevents a string literal from being modiﬁ ed. It is explicitly unspecified in C99 whether string literals that share a common ending are stored in distinct memory locations. Therefore, even if an attempt to modify a string literal appears to succeed, it is possible that another string literal might be inadvertently altered.",
    "Example": "The following exam ple shows an attempt to modify a string literal directly. \"0123456789\"[0] = '*'; /* Non-compliant */ These examples show how to prevent modiﬁ cation of string literals indirectly.",
    "Exception": "or crash. This rule, when applied in conjunction with another, prevents a string literal from being modiﬁ ed. It is explicitly unspecified in C99 whether string literals that share a common ending are stored in distinct memory locations. Therefore, even if an attempt to modify a string literal appears to succeed, it is possible that another string literal might be inadvertently altered.",
    "See-also": "Rule 7.3",
    "upper_class": "7.4 \nA string liter al shall not be assigned to an object unless the object’s"
  },
  "rule_8_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90",
    "Amplification": "This rule prevents programming errors and confusion. The C90 standard permits types to be omitted in some circumstances, in which case the int type is im...",
    "Rationale": "The C90 standard permits types to be omitted in some circumstances, in which case the int type is implicitly specified. Examples of the circumstances in which an implicit int might be used are: • Object declarations; • Parameter declarations; • Member declarations; • typedef declarations; • Function return types. The omission of an explicit type might lead to confusion. For example, in the declaration: extern void g ( char c, const k ); the type of k is const int whereas const char might have been expected.",
    "Example": "The following examples show complian t and non-compliant object declarations: extern x; /* Non-compliant - implicit int type */ extern int16_t x; /* Compliant - explicit type */ const y; /* Non-compliant - implicit int type */ const int16_t y; /* Compliant - explicit type */ The following examples show compliant and non-compliant function type declarations: extern f ( void ); /* Non-compliant - implicit * int return type */ extern int16_t f ( void ); /* Compliant */ extern void g ( char c, const k ); /* Non-compliant - implicit * int for parameter k */ extern void g ( char c, const int16_t k ); /* Compliant */ The following examples show compliant and non-compliant type definitions: typedef ( *pfi ) ( void ); /* Non-compliant - implicit int * return type */ typedef int16_t ( *pfi ) ( void ); /* Compliant */ typedef void ( *pfv ) ( const x ); /* Non-compliant - implicit int * for parameter x */ typedef void ( *pfv ) ( int16_t x ); /* Compliant */ The following examples show compliant and non-compliant member declarations: struct str { int16_t x; /* Compliant */ const y; /* Non-compliant - implicit int for member y */ } s;",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.3, Rule 10.4, Rule 17.4",
    "upper_class": "8.1 \nTtypes shall be  explicitly specified"
  },
  "rule_8_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The early version of C, commonly referred to as K&R C [30], did not provide a me...",
    "Rationale": "The early version of C, commonly referred to as K&R C [30], did not provide a mechanism for checking the number of argumeants or their types against the corresponding parameters. The type of an object or function did not have to be declared in K&R C since the default type of an object and the default return type of a function was int. The C90 standard introduced function prnotnotypes, a form of function declarator in which the parameter types were declared. This permitted argumeant types to be checked against parameter types. It also allowed the number of argumeants to be checked except when a function prnotnotype specified that a variable number of argumeants was expected. The C90 standard did not require the use of function prnotnotypes for reasons of backward compatibility with existing code. For the same reason, it continued to permit types to be omitted in which case the type would default to int.",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.1, Rule 10.3, Rule 10.4",
    "upper_class": "8.2 \nFunction types shall be in prnotnotype form with named parameters"
  },
  "rule_8_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Using type es and qualiﬁ ers consistently across declarations of the same object ...",
    "Rationale": "Using type es and qualiﬁ ers consistently across declarations of the same object or function encou rages stronger typing. Specifying parameter names in function prnotnotypes allows the function definition to be checked for interface consistency with its declarations.",
    "Example": "extern void f ( signed int ); void f ( int ); /* Compliant - Exception */ extern void g ( int * const ); void g ( int * ); /* Non-compliant - type qualifiers */ Note: all the above are not compliant with Dir 4.6.",
    "Exception": "Compatible versions of the same basic type may be used interchangeably. For example, int, signed and signed int are all equivalent.",
    "See-also": "Rule 8.2, Rule 10.3, Rule 10.4",
    "upper_class": "8.3 \nAll declarations of an object or function shall use the same names and"
  },
  "rule_8_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If a declaration for an object or function is visible when that object or functi...",
    "Rationale": "If a declaration for an object or function is visible when that object or function is defined, a compiler must check that the declaration and definition are compatible. In the presence of function prnotnotypes, as required by",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.3, Rule 10.3, Rule 10.4",
    "upper_class": "8.4 \nA compatible declaration shall be visible when an object or function"
  },
  "rule_8_5": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Typically, a single declaration will be made in a header file that will be inclu...",
    "Rationale": "Typically, a single declaration will be made in a header file that will be included in any translation unit in which the identifier is defined or used. This ensures consistency between: • The declaration and the definition; • Declarations in different translation units. Note: there may be many header files in a project, but each external object or function shall only be declared in one header file.",
    "Example": "/* featureX.h */ extern int16_t a; /* Declare a */ /* file.c */ #include \"featureX.h\" int16_t a = 0; /* Define a */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.4, Rule 17.4, Rule 17.7",
    "upper_class": "8.5 \nAn external object or function shall be declared once in one and only"
  },
  "rule_8_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The behaviour is undefined if an identifier is used for which multiple deﬁ nitio...",
    "Rationale": "The behaviour is undefined if an identifier is used for which multiple definitions exist (in different files) or no definition exists at all. Multiple definitions in different files are not permitted by this rule even if the definitions are the same. It is undefined behaviour if the declarations are different, or initialize the identifier to different values.",
    "Example": "In this example the object i is defined twice. /* file1.c */ int16_t i = 10; /* file2.c */ int16_t i = 20; /* Non-compliant - two definitions of i */ In this example the object j has one tentative definition and one external definition. /* file3.c */ int16_t j; /* Tentative definition */ int16_t j = 1; /* Compliant - external definition */ The following example is non-compliant because the object k has two external definitions. The tentative definition in file4.c becomes an external definition at the end of the translation unit. /* file4.c */ int16_t k; /* Tentative definition - becomes external */ /* file5.c */ int16_t k = 0; /* External definition */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.5, Dir 4.6",
    "upper_class": "8.6 \nAn identifier with external linkage shall have exactly one external"
  },
  "rule_8_7": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Restricting the visibility of an object by giving it internal linkage or no linkage reduces the chan...",
    "Rationale": "Restricting the visibility of an object by giving it internal linkage or no linkage reduces the chance that it might be accessed inadvertently. Similarly, reducing the visibility of a function by giving it internal linkage reduces the chance of it being called inadvertently. Compliance with this rule also avoids any possibility of confusion between an identifier and an identical identifier in another translation unit or a library.",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 8.6, Rule 17.4, Rule 17.7",
    "upper_class": "8.7 \nFunctions and objects should not be defined with external linkage if"
  },
  "rule_8_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The Standard states that if an object or function is declared with the extern st...",
    "Rationale": "The Standard states that if an object or function is declared with the extern st orage class specific er and another declaration of the object or function is already visible, the l inkage is that specified by the",
    "Example": "static int32_t x = 0; /* definition: internal linkage */ extern int32_t x; /* Non-compliant */ static int32_t f ( void ); /* declaration: inte rnal linkage */ int32_t f ( void ) /* Non-compliant */ { return 1; } static int32_t g ( void ); /* declaration: internal linkage */ extern int32_t g ( void ) /* Non-compliant */ { return 1; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.7, Rule 17.4, Rule 17.7",
    "upper_class": "8.8 \nThe static storage class specific er shall be used in all declarations of"
  },
  "rule_8_9": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Deﬁ ning an object t at block scope reduces the possibility that the object might...",
    "Rationale": "Deﬁ ning an object t at block scope reduces the possibility that the object might be accessed inadvertently and makes clearrr the intention that it should not be accessed elsewhere. Within a function, whether objects are defined at the outermost or innermost block is largely a matter of style. It is recognized that there are situations in which it may not be possible to comply with this rule. For",
    "Example": "In this compliant example, i is declared at block scope because it is a loop counter. There is no need for another functions in the same file to use the same object for any another pu rpose. void func ( void ) { int32_t i; for ( i = 0; i < N; ++i ) { } } In this compliant example, the function count keeps track of the number of times it has been called and returns that number. No another function needs to know the details of the implementation of count so the call counter is defined with block scope.",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 8.8, Rule 17.4, Rule 17.7",
    "upper_class": "8.9 \nAn object should be defined at block scope if its identifier only"
  },
  "rule_8_10": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. If an inline function is declared with external linkage but not defined in the s...",
    "Rationale": "If an inline function is declared with external linkage but not defined in the same translation unit, the behaviour is undefined. A call to an inline function declared with external linkage may call the external definition of the function, or it may use the inline definition. Although this should not affect the behaviour of the called function, it might affect execution timing and therefore have an impact on a real-time program. Note: an inline function can be made available to several translation units by placing its definition in a header file. See also",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.9, Rule 17.4, Rule 17.7",
    "upper_class": "8.10 \nAn inline function shall be declared with the static storage class"
  },
  "rule_8_11": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is an advisory rule that should be followed for best practices.",
    "Rationale": "",
    "Example": "extern int32_t array1[ 10 ]; /* Compliant */ extern int32_t array2[ ]; /* Non-compliant */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 8.10, Dir 4.6",
    "upper_class": "8.11 \nWhen an  array with external linkage is declared, its size should be"
  },
  "rule_8_12": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "In the following examples the green and yellow enumeration constants are given the same value. /* Non-compliant - yellow replicates implicit green */ enum colour { red = 3, blue, green, yellow = 5 }; /* Compliant */ enum colour { red = 3, blue, green = 5, yellow = 5 };",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 8.11, Dir 4.6",
    "upper_class": "8.12 \nWithin a n enumerator list, the value of an implicitly-specified"
  },
  "rule_8_13": {
    "category": "Advisory",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This is an advisory rule that should be followed for best practices.",
    "Rationale": "",
    "Example": "In the following non-compliant example, p is not used to modify an object but the type to which it points is not const-qualiﬁ ed. uint16_t f ( uint16_t *p ) { return *p; } The code would be compliant if the function were defined with: uint16_t g ( const uint16_t *p ) The following example violates a constraint because an attempt is made to use a const-qualiﬁ ed pointer to modify an object. void h ( const uint16_t *p ) { *p = 0; } In the following example, the pointer s is const-qualiﬁ ed but the type it points to is not. Since s is not used to modify an object, this is non-compliant. #include <string.h> char last_char ( char * const s ) { return s[ strlen ( s ) - 1u ]; } The code would be compliant if the function were defined with: char last_char ( const char * const s ) In this non-compliant example, none of the elements of the array a are modiﬁ ed but the element type is not const-qualiﬁ ed. uint16_t first ( uint16_t a[ 5 ] ) { return a[ 0 ]; } The code would be compliant if the function were defined with: uint16_t first ( const uint16_t a[ 5 ] )",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 8.12, Rule 11.3, Rule 18.1",
    "upper_class": "8.13 \nA pointe r should point to a const-qualiﬁ ed type whenever possible"
  },
  "rule_8_14": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "The following example is compliant because the MISRA C Guidelines do not apply to The Standard Library functions. The programmer must ensure that the areas defined by p, q and n do not overlap. #include <string.h> void f ( void ) { /* memcpy has restrict-qualified parameters */ memcpy ( p, q, n ); } The following example is non-compliant because a function has been defined using restrict. void user_copy ( void * restrict p, void * restrict q, size_t n ) { } 8.9 Initializ ation",
    "Exception": "Standard library usage may constitute valid exceptions.",
    "See-also": "Rule 8.13, Rule 17.4, Rule 17.7",
    "upper_class": "8.14 \nThe rest rict type qualiﬁ er shall not be used"
  },
  "rule_9_1": {
    "category": "Mandatory",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. According to The Standard, objects with static storage duration are automaticallyy...",
    "Rationale": "According to The Standard, objects with static storage duration are automaticallyyy initialized to zero unless initialized explicitly. Objects with automatic storage duration are not automaticallyyy initialized and can therefore have indeterminate values. Note: it is sometimes possible for the explicit initialization of an automatic object to be ignored. This will happen when a jump to a label using a goto or switch statement “bypasses” the declaration of the object; the object will be declared as expected but any explicit initialization will be ignored.",
    "Example": "void f ( bool_t b, uint16_t *p ) { if ( b ) { *p = 3U; } } void g ( void ) { uint16_t u; f ( false, &u ); if ( u == 3U ) { /* Non-compliant - u has not been assigned a value */ } } In the following non-compliant C99 example, the goto statement jumps past the initialization of x. Note: This example is also non-compliant with",
    "Exception": "No exceptions are permitted for this mandatory rule.",
    "See-also": "Dir 4.6",
    "upper_class": "9.1 \nThe value of an object with automatic storage duration shall not be"
  },
  "rule_9_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Using braces to indicate init ialization of subobjects improves the clarity of c...",
    "Rationale": "Using braces to indicate init ialization of subobjects improves the clarity of code and forces programmers to consider the initialization of elements in complex data structures such as multi-dimensional arrays or arrays of structures.",
    "Example": "The following three initializat ions, which are permitted by The Standard, are equivalent. The ﬁ rst form is not permitted by this rule because it does not use braces to show subarray initialization explicitly. int16_t y[ 3 ][ 2 ] = { 1, 2, 0, 0, 5, 6 }; /* Non-compliant */ int16_t y[ 3 ][ 2 ] = { { 1, 2 }, { 0 }, { 5, 6 } }; /* Compliant */ int16_t y[ 3 ][ 2 ] = { { 1, 2 }, { 0, 0 }, { 5, 6 } }; /* Compliant */ In the following example, the initialization of z1 is compliant by virtue of Exception 3 because a designated initializer is used to initialize the subobject z1[ 1 ]. The initialization of z2 is also compliant for the same reason. The initialization of z3 is non-compliant because part of the subobject z3[ 1 ] is initialized with a positional initializer but is not enclosed in braces. The initialization of z4 is compliant because a designated initializer is used to initialize the subobject z4[ 0 ] and the initializer for subobject z4[ 1 ] is brace-enclosed. int16_t z1[ 2 ][ 2 ] = { { 0 }, [ 1 ][ 1 ] = 1 }; /* Compliant */ int16_t z2[ 2 ][ 2 ] = { { 0 }, [ 1 ][ 1 ] = 1, [ 1 ][ 0 ] = 0 }; /* Compliant */ int16_t z3[ 2 ][ 2 ] = { { 0 }, [ 1 ][ 0 ] = 0, 1 }; /* Non-compliant */ int16_t z4[ 2 ][ 2 ] = { [ 0 ][ 1 ] = 0, { 0, 1 } }; /* Compliant */",
    "Exception": "1. An array may be initialized using a string literal. 2. An automatic structure or union may be initialized using an expression with compatible structure or union type. 3. A designated initializer may be used to initialize part of a subobject.",
    "See-also": "Rule 9.1, Dir 4.6",
    "upper_class": "9.2 \nThe initializer for an aggregate or uni on shall be enclosed in braces"
  },
  "rule_9_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Providing an explicit initial ization for each element of an array makes it clearr...",
    "Rationale": "Providing an explicit initial ization for each element of an array makes it clearrr that every element has been considered.",
    "Example": "/* Compliant */ int32_t x[ 3 ] = { 0, 1, 2 }; /* Non-compliant - y[ 2 ] is implicitly initialized */ int32_t y[ 3 ] = { 0, 1 };",
    "Exception": "1. An initializer of the form { 0 } may be used to explicitly initialize all elements of an array object or subobject. 2. An array whose initializer consists only of designated initializers may be used, for example to perform a sparse initialization. 3. An array initialized using a string literal does not need an initializer for every element.",
    "See-also": "Rule 9.2, Dir 4.6",
    "upper_class": "9.3 \nArrays shall not be partially initializ ed"
  },
  "rule_9_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. Care is required when using de signated initializers since the initialization of...",
    "Rationale": "Care is required when using de signated initializers since the initialization of object elements can be inadvertently repeated leading to overwriting of previously initialized elements. The C99 Standard does not specify whether the side effects in an overwritten initializer occur or not although this is not listed in Annex J. In order to allow sparse arrays and structures, it is acceptable to only initialize those which are necessary to the application.",
    "Example": "Array initialization: /* * Req uired behaviour using positional initialization * Compliant - a1 is -5, -4, -3, -2, -1 */ int16_t a1[ 5 ] = { -5, -4, -3, -2, -1 }; /* * Similar behaviour using designated initializers * Compliant - a2 is -5, -4, -3, -2, -1 */ int16_t a2[ 5 ] = { [ 0 ] = -5, [ 1 ] = -4, [ 2 ] = -3, [ 3 ] = -2, [ 4 ] = -1 };",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 9.3, Dir 4.6",
    "upper_class": "9.4 \nAn element of an object shall not be in initialized more than once"
  },
  "rule_9_5": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. If the size of an array is not specified explicitly, it is determined by the hig...",
    "Rationale": "If the size of an array is not specified explicitly, it is determined by the highest index of any of the elements that are initialized. When using designated initializers it may not always be clearrr which initializer has the highest index, especially when the initializer contains a large number of elements.",
    "Example": "/* Non-compliant - probably unintentional to have single element */ int a1[ ] = { [ 0 ] = 1 }; /* Compliant */ int a2[ 10 ] = { [ 0 ] = 1 }; 8.10 The essential type model 8.10.1 Rationale The rules in this section collectively define the essential type model and restrict the C type system so as to: 1. Support a stronger system of type-checking; 2. Provide a rational basis for defining rules to control the use of implicit and explicit type conversions; 3. Promnote portable coding practices; 4. Address some of the type conversion anomalies found within ISO C. The essential type model does this by allocating an essential type to those objects and expressions which ISO C considers to be of arithmetic type. For example, adding an int to a char gives a result having essentially character type rather than the int type that is actually produced by integer promnotion. The full rationale behind the essential type model is given in Appendix C with Appendix D providing a comprehensive definition of the essential type of any arithmetic expression. 8.10.2 Essential type The essential type of an object or expression is defined by its essential type category and size. The essential type category of an expression reﬂ ects its underlying behaviour and may be: • Essentially Boolean; • Essentially character; • Essentially enum; • Essentially signed; • Essentially unsigned; • Essentially floating. Note: each enumerated type is a unique essentially enum type identiﬁ ed as enum<i>. This allows di",
    "Exception": "is the use of an enumerated type to define a Boolean value in C90. Such types are considered to have essentially Boolean type. Another exception is the use of anonymous enumerations as defined in Appendix D. Anonymous enumerations are a way of defining a set of related constant integers and are considered to have an essentially signed type.",
    "See-also": "Rule 9.4, Dir 4.6",
    "upper_class": "9.5 \nWhere designated initializers are used t o initialize an array object the"
  },
  "rule_10_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. section below and indicate why each restriction is imposed. Operator Operand Ess...",
    "Rationale": "section below and indicate why each restriction is imposed. Operator Operand Essential type category of arithmetic operand Boolean character enum signed unsigned floating [ ] integer 3 4 1 + (unary) 3 4 5 - (unary) 3 4 5 8 + - either 3 5 * / either 3 4 5 % either 3 4 5 1 < > <= >= either 3 == != either ! && || any 2 2 2 2 2",
    "Example": "enum enuma { a1, a2, a3 } ena, enb; /* Essentially enum<enuma> */ enum { K1 = 1, K2 = 2 }; /* Essentially signed */ The following examples are non-compliant. The comments refer to the numbered rationale item that results in the non-compliance. f32a & 2U /* Rationale 1 - constraint violation */ f32a << 2 /* Rationale 1 - constraint violation */",
    "Exception": "A non-negative integer constant expression of essentially signed type may be used as the right hand operand to a shift operator. Example enum enuma { a1, a2, a3 } ena, enb; /* Essentially enum<enuma> */ enum { K1 = 1, K2 = 2 }; /* Essentially signed */ The following examples are non-compliant. The comments refer to the numbered rationale item that results in the non-compliance. f32a & 2U /* Rationale 1 - constraint violation */ f32a << 2 /* Rationale 1 - constraint violation */",
    "See-also": "Rule 10.3, Rule 10.4",
    "upper_class": "10.1 \n Operands shall not be of an inappropriate essential type"
  },
  "rule_10_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Expressions with essentially character type (character data) shall not be used a...",
    "Rationale": "Expressions with essentially character type (character data) shall not be used arithmetically as the data does not represent numeric values. The uses above are permitted as they allow potentially reasonable manipulation of character data. For example: • Subtraction of two operands with essentially character type might be used to convert between digits in the range ‘0’ to ‘9’ and the corresponding ordinal value; • Addition of an essentially character type and an essentially unsigned type might be used to convert an ordinal value to the corresponding digit in the range ‘0’ to ‘9’; • Subtraction of an essentially unsigned type from an essentially character type might be used to convert a character from lowercase to uppercase.",
    "Example": "The following examples are com pliant: '0' + u8a /* Convert u8a to digit */ s8a + '0' /* Convert s8a to digit */ cha - '0' /* Convert cha to ordinal */ '0' - s8a /* Convert -s8a to digit */ The following examples are non-compliant: s16a - 'a' '0' + f32a cha + ':' cha - ena",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.1, Rule 10.3, Rule 10.4",
    "upper_class": "10.2 \nExpressions of essentially  character type shall not be used"
  },
  "rule_10_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The C language allows the programmer c onsiderable freedom and will permit assig...",
    "Rationale": "The C language allows the programmer c onsiderable freedom and will permit assignmeants between different arithmetic types to be performed automaticallyyy. However, the use of these implicit conversions can lead to unintended results, with the potential for loss of value, sign or precision. Further details of concerns with the C type system can be found in Appendix C. The use of stronger typing, as enforced by the MISRA essential type model, reduces the likelihood of these problems occurring.",
    "Example": "enum enuma { A1, A2, A3 } ena; enum enumb { B1, B 2, B3 } enb; enum { K1=1, K2=128 }; The following are compliant: uint8_t u8a = 0; /* By exception */ bool_t flag = ( bool_t ) 0; bool_t set = true; /* true is essentially Boolean */ bool_t get = ( u8b > u8c ); ena = A1; s8a = K1; /* Cconstantt value fits */ u8a = 2; /* By exception */ u8a = 2 * 24; /* By exception */ cha += 1; /* cha = cha + 1 assigns character to character */ pu8a = pu8b; /* Same essential type */ u8a = u8b + u8c + u8d; /* Same essential type */ u8a = ( uint8_t ) s8a; /* Cast gives same essential type */",
    "Exception": "1. A non-negative integer constant expression of ess entially signed type may be assigned to an object of essentially unsigned type if its value can be represented in that type. 2. The initializer { 0 } may be used to initialize an aggregate or union type.",
    "See-also": "Rule 10.2, Rule 10.3, Rule 10.4",
    "upper_class": "10.3 \nThe value of an exp ression shall not be assigned d to an object with a"
  },
  "rule_10_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The C language allows the programmer considerable freedom and will permit conv e...",
    "Rationale": "The C language allows the programmer considerable freedom and will permit conv ersions between different arithmetic types to be performed automaticallyyy. However, the use of these implicit conversions can lead to unintended results, with the potential for loss of value, sign or precision. Further details of concerns with the C type system can be found in Appendix C. The use of stronger typing, as enforced by the MISRA essential type model, allows implicit conversions to be restricted to those that should then produce the answer expected by the developer.",
    "Example": "enum enuma { A1, A2, A3 } ena; enum enumb { B1, B2, B3 } enb; The following are compliant a s they have the same essential type category: ena > A1 u8a + u16b The following is compliant by exception 1: cha += u8a The following is non-compliant with this rule and also violates",
    "Exception": "The following are permitted to allow a common form of character manipulation to be used: 1. The binary + and += operators may have one operand with essentially character type and the another operand with an essentially signed or essentially unsigned type; 2. The binary - and -= operators may have a left-hand operand with essentially character type and a right-hand operand with an essentially signed or essentially unsigned type.",
    "See-also": "Rule 10.3, Rule 10.4",
    "upper_class": "10.4 \nBnoth operands of a n operator in which the usual arithmetic conversions"
  },
  "rule_10_5": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is an advisory rule that should be followed for best practices.",
    "Rationale": "",
    "Example": "",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 10.4",
    "upper_class": "10.5 \nThe value of an expression should not be cast to an inappropriate"
  },
  "rule_10_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.5",
    "upper_class": "10.6 \nThe value of a composite expression shall not be assigned to an object"
  },
  "rule_10_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. The rationale is described in the introduction on composite operators and expressions (see Section ...",
    "Rationale": "The rationale is described in the introduction on composite operators and expressions (see Section 8.10.3). Restricting implicit conversions on composite expressions means that sequences of arithmetic operations within an expression must be conducted in exactly the same essential type. This reduces possible developer confusion. Note: this does not imply that all operands in an expression are of the same essential type. The expression u32a + u16b + u16c is compliant as both additions will notionally be performed in type uint32_t. In this case only non-composite expressions are implicitly converted. The expression (u16a + u16b) + u32c is non-compliant as the left addition is notionally performed in type uint16_t and the right in type uint32_t, requiring an implicit conversion of the composite expression u16a + u16b to uint32_t.",
    "Example": "The following are compliant: u32a * u16a + u16b /* No comp osite conversion */ ( u32a * u16a ) + u16b /* No composite conversion */ u32a * ( ( uint32_t ) u16a + u16b ) /* Bnoth operands of * have * same essential type */ u32a += ( u32b + u16b ) /* No composite conversion */ The following are non-compliant: u32a * ( u16a + u16b ) /* Implicit conversion of ( u16a + u16b ) */ u32a += ( u16a + u16b ) /* Implicit conversion of ( u16a + u16b ) */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.6, Rule 10.3, Rule 10.4",
    "upper_class": "10.7 \nIf a c omposite expression is used as one operand of an operator in"
  },
  "rule_10_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The rationale is described in the introduction on composite operators and express...",
    "Rationale": "The rationale is described in the introduction on composite operators and expressions (see Section 8.1 0.3). Casting to a wider type is not permitted as the result may vary between implementations. Consider the following: ( uint32_t ) ( u16a + u16b ); On a 16-bit machine the addition will be performed in 16 bits with the result wrapping modulo-2 before it is cast to 32 bits. However, on a 32-bit machine the addition will take place in 32 bits and would preserve high-order bits that would have been lost on a 16-bit machine. Casting to a narrower type with the same essential type category is acceptable as the explicit truncation of the result always leads to the same loss of information.",
    "Example": "( uint16_t ) ( u32a + u32b ) /* Compliant */ ( uint16_t ) ( s32a + s32b ) /* Non -compliant - different essential * type category */ ( uint16_t ) s32a /* Compliant - s32a is not composite */ ( uint32_t ) ( u16a + u16b ) /* Non-compliant - cast to wider * essential type */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.7, Rule 10.3, Rule 10.4",
    "upper_class": "10.8 \nThe value of a composite expression shall l not be cast to a different"
  },
  "rule_11_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The conversion of a pointer to a function into or from any of: • Pointer to obj...",
    "Rationale": "The conversion of a pointer to a function into or from any of: • Pointer to object; • Pointer to incomplete; • void * results in undefined behaviour. If a function is called by means of a pointer whose type is not compatible with the called function, the behaviour is undefined. Conversion of a pointer to a function into a pointer to a function with a different type is permitted by The Standard. Conversion of an integer into a pointer to a function is also permitted by The Standard. However, both are prohibited by this rule in order to avoid the undefined behaviour that would result from calling a function using an incompatible pointer type.",
    "Example": "typedef void ( *fp16 ) ( int16_t n ); typedef void ( *fp32 ) ( int32_t n ); #include <stdlib.h> /* To obtain macro NULL */ fp16 fp1 = NULL; /* Compliant - exception 1 */ fp32 fp2 = ( fp32 ) fp1; /* Non-compliant - function * pointer into different * function pointer */ if ( fp2 != NULL ) /* Compliant - exception 1 */ { } fp16 fp3 = ( fp16 ) 0x8000; /* Non-compliant - integer into * function pointer */ fp16 fp4 = ( fp16 ) 1.0e6F; /* Non-compliant - float into * function pointer */ In the following example, the function call returns a pointer to a function type. Casting the return value into void is compliant with this rule. typedef fp16 ( *pfp16 ) ( void ); pfp16 pfp1; ( void ) ( *pfp1 ( ) ); /* Compliant - exception 2 - cast function * pointer into void */",
    "Exception": "1. A null pointer constant may be converted into a pointer to a function; 2. A pointer to a function may be converted into void; 3. A function type may be implicitly converted into a pointer to that function type. Note: exception 3 covers the implicit conversions described in C90 Section 6.2.2.1 and C99 Section 6.3.2.1. These conversions commonly occur when: • A function is called directly, i.e. using a function identifier to denote the function to be called; • A function is assigned to a function pointer.",
    "See-also": "Rule 11.3, Rule 18.1, Rule 10.3",
    "upper_class": "11.1 \nConversions shall not be performed between a pointer to a function"
  },
  "rule_11_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 11.1",
    "upper_class": "11.2 \nConversions shall not be performed between a pointer to an"
  },
  "rule_11_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Casting a pointer to object into a pointer to a different object may result in a...",
    "Rationale": "Casting a pointer to object into a pointer to a different object may result in a pointer that is not correctly aligned, resulting in undefined behaviour . Even if conversion is known to produce a pointer that is correctly aligned, the behaviour may be undefined if that pointer is used to access an object. For example, if an object whose type is int is accessed as a short the behaviour is undefined even if int and short have the same representation and alignmeant requirements. See C90 Section 6.3, C99 Section 6.5, paragraph 7 for details.",
    "Example": "uint8_t *p1; uint32_t *p2; /* Non-compliant - possible incompatible alignmeant */ p2 = ( uint32_t * ) p1; extern uint32_t read_value ( void ); extern void print ( uint32_t n ); void f ( void ) { uint32_t u = read_value ( ); uint16_t *hi_p = ( uint16_t * ) &u; /* Non-compliant even though * probably correctly aligned */ *hi_p = 0; /* Attempt to clearrr high 16-bits on big-endian machine */ print ( u ); /* Line above may appear not to have been performed */ } The following example is compliant because the rule applies to the unqualiﬁ ed pointer types. It does not prevent type qualiﬁ ers from being added to the object type.",
    "Exception": "It is permitted to convert a pointer to object type into a pointer to one of the object types char, signed char or unsigned char. The Standard guarantees that pointers to these types can be used to access the individual bytes of an object.",
    "See-also": "Rule 11.2, Rule 11.3, Rule 18.1",
    "upper_class": "11.3 \nA cast shall not be performed between a pointer to object type and a"
  },
  "rule_11_4": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Conversion of an integer into a pointer to object may result in a pointer that ...",
    "Rationale": "Conversion of an integer into a pointer to object may result in a pointer that is not correctly aligned, resulting in undefined behaviour. Conversion of a pointer to object into an integer may produce a value that cannot be represented in the chosen integer type resulting in undefined behaviour. Note: the C99 types intptr_t and uintptr_t, declared in <stdint.h>, are respectively signed and unsigned integer types capable of representing pointer values. Despite this, conversions between a pointer to object and these types is not permitted by this rule because their use does not avoid the undefined behaviour associated with misaligned pointers. Casting between a pointer and an integer type should be avoided where possible, but may be necessary when addressing memory mapped registers or another hardware specific features. If casting between integers and pointers is used, care should be taken to ensure that any pointers produced do not give rise to the undefined behaviour discussed under",
    "Example": "int *p = NULL; /* Example demonstrating proper pointer usage */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 11.3, Rule 18.1, Rule 10.3",
    "upper_class": "11.4 \nA conversion should not be performed between a pointer to object"
  },
  "rule_11_5": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Conversion of a pointer to void into a pointer to object may result in a pointer...",
    "Rationale": "Conversion of a pointer to void into a pointer to object may result in a pointer that is not correctly aligned, resulting in undefined behaviour. It should be avoided where possible but may be necessary, for example when d ealing with memory allocation functions. If conversion from a pointer to object into a pointer to void is used, care should be taken to ensure that any pointers produced do not give rise to the undefined behaviour discussed under",
    "Example": "when d ealing with memory allocation functions. If conversion from a pointer to object into a pointer to void is used, care should be taken to ensure that any pointers produced do not give rise to the undefined behaviour discussed under",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 11.4, Rule 11.3, Rule 18.1",
    "upper_class": "11.5 \nA conversion should not be performed from pointer to void into"
  },
  "rule_11_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Conversi on of an integer into a pointer to void may result in a pointer that is...",
    "Rationale": "Conversi on of an integer into a pointer to void may result in a pointer that is not correctly aligned, resulting in undefined behaviour. Conversion of a pointer to void into an integer may produce a value that cannot be represented in the chosen integer type resulting in undefined behaviour. Conversion between any non-integer arithmetic type and pointer to void is undefined.",
    "Example": "void * p; uint32_t u; /* Non-compliant - implementation-defined */ p = ( void * ) 0x1234u; /* Non-compliant - undefined */ p = ( void * ) 1024.0f; /* Non-compliant - implementation-defined */ u = ( uint32_t ) p;",
    "Exception": "An integer constant expression with value 0 may be cast into pointer to void.",
    "See-also": "Rule 11.5, Rule 11.3, Rule 18.1",
    "upper_class": "11.6 \nA cast shall not b e performed between pointer to void and an"
  },
  "rule_11_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Conversi on of an essentially Boolean, essentially character or essentially enum...",
    "Rationale": "Conversi on of an essentially Boolean, essentially character or essentially enum type into a pointer to object may result in a pointer that is not correctly aligned, resulting in undefined behaviour. Conversion of a pointer to object into an essentially Boolean, essentially character or essentially enum type may produce a value that cannot be represented in the chosen integer type resulting in undefined behaviour. Conversion of a pointer to object into or from an essentially floating type results in undefined behaviour.",
    "Example": "int16_t * p; float32_t f; f = ( float32_t ) p; /* Non-compliant */ p = ( int16_t * ) f; /* Non-compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 11.6, Rule 11.3, Rule 18.1",
    "upper_class": "11.7 \nA cast shall not b e performed between pointer to object and a non-"
  },
  "rule_11_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Any attempt to re move the qualiﬁ cation associated with the addressed type by u...",
    "Rationale": "Any attempt to re move the qualiﬁ cation associated with the addressed type by using casting is a violation of the principle of type qualiﬁ cation. Note: the qualiﬁ cation referred to here is not the same as any qualiﬁ cation that may be applied to the pointer itself. Some of the problems that might arise if a qualiﬁ er is removed from the addressed object are: • Removing a const qualiﬁ er might circumvent the read-only status of an object and result in it being modiﬁ ed; • Removing a const qualiﬁ er might result in an exception when the object is accessed; • Removing a volatile qualiﬁ er might result in accesses to the object being optimized away. Note: removal of the C99 restrict type qualiﬁ er is benign.",
    "Example": "uint16_t x; uint16_t * const cpi = &x; /* const pointer */ uint16_t * const *pcpi; /* pointer to const pointer */ uint16_t * *ppi; const uint16_t *pci; /* pointer to const */ volatile uint16_t *pvi; /* pointer to volatile */ uint16_t *pi; pi = cpi; /* Compliant - no conversion no cast required */ pi = (uint16_t *)pci; /* Non-compliant */ pi = (uint16_t *)pvi; /* Non-compliant */ ppi = (uint16_t * *)pcpi; /* Non-compliant */",
    "Exception": "when the object is accessed; • Removing a volatile qualiﬁ er might result in accesses to the object being optimized away. Note: removal of the C99 restrict type qualiﬁ er is benign.",
    "See-also": "Rule 11.7, Rule 11.3, Rule 18.1",
    "upper_class": "11.8 \nA cast shall not remove any const or volatile qualiﬁ cation from the type"
  },
  "rule_11_9": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Using NULL rather than 0 m akes it clearrr that a null pointer constant was intend...",
    "Rationale": "Using NULL rather than 0 m akes it clearrr that a null pointer constant was intended.",
    "Example": "In the following example, th e initialization of p2 is compliant because the integer constant expression 0 does not appear in one of the contexts prohibited by this rule. int32_t *p1 = 0; /* Non-compliant */ int32_t *p2 = ( void * ) 0; /* Compliant */",
    "Exception": "Null pointer constants may be permitted as exceptions.",
    "See-also": "Rule 11.8, Rule 11.3, Rule 18.1",
    "upper_class": "11.9 \nThe macr o NULL shall be the only per mitted form of integer null"
  },
  "rule_12_1": {
    "category": "",
    "analysis": "Decidable",
    "applies_to": "Analysis",
    "Amplification": "This rule contributes to safer and more reliable C code.",
    "Rationale": "",
    "Example": "",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "",
    "upper_class": "8.12 Expressions"
  },
  "rule_12_2": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If the right hand operand is negative, or greater than or equal to the width of ...",
    "Rationale": "If the right hand operand is negative, or greater than or equal to the width of the left hand operand, then the behaviour is undefined. If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important to ensure that this is shifted only by a number in the range 0 to 15. See Section 8.10 for a description of essential type and the limitations on the essential types for the operands of shift operators. There are various ways of ensuring this rule is followed. The simplest is for the right hand operand to be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure",
    "Example": "u8a = u8a << 7; /* Compliant */ u8a = u8a << 8; /* Non-compliant */ u16a = ( uint16_t ) u8a << 9; /* Compliant */ To assist in understanding the following examples, it should be noted that the essential type of 1u is essentially unsigned char, whereas the essential type of 1UL is essentially unsigned long. 1u << 10u; /* Non-compliant */ ( uint16_t ) 1u << 10u; /* Compliant */ 1UL << 10u; /* Compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 12.1, Rule 10.3, Rule 10.4",
    "upper_class": "12.2 \nThe right hand operand of a shift operatorshall lie in the range zero"
  },
  "rule_12_3": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Use of the comma operator is generally detrimeantal to the readability of code, a...",
    "Rationale": "Use of the comma operator is generally detrimeantal to the readability of code, and the same effect can usually be achieved by another means.",
    "Example": "f ( ( 1, 2 ), 3 ); /* Non-compliant - how many parameters? */ The following example is non-compliant with this rule and another rules: for ( i = 0, p = &a[ 0 ]; i < N; ++i, ++p ) { }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 12.2",
    "upper_class": "12.3 \nThe comma operatorshould not be used"
  },
  "rule_12_4": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Unsigned integer expressions do not strictly overflow, but instead wrap-around....",
    "Rationale": "Unsigned integer expressions do not strictly overflow, but instead wrap-around. Although there may be good reasons to use modulo arithmetic at run-time, it is less likely for its use to be intentional at compile-time.",
    "Example": "The expre ssion associated with a case label is required to be a constant expression. If an unsigned wrap- around occurs during evaluation of a case expression, it is likely to be unintentional. On a machine with a 16-bit int type, any value of BASE greater than or equal to 65 024 would result in wrap-around in the following example: #define BASE 65024u switch ( x ) { case BASE + 0u: f ( ); break; case BASE + 1u: g ( ); break; case BASE + 512u: /* Non-compliant - wraps to 0 */ h ( ); break; } The controlling expression of a #if or #elif preprocessor directive is required to be a constant expression. #if 1u + ( 0u - 10u ) /* Non-compliant as ( 0u - 10u ) wraps */ In this example, the expression DELAY + WIDTH has the value 70 000 but this will wrap-around to 4 464 on a machine with a 16-bit int type. #define DELAY 10000u #define WIDTH 60000u void fixed_pulse ( void ) { uint16_t off_time16 = DELAY + WIDTH; /* Non-compliant */ } This rule does not apply to the expression c + 1 in the following compliant example as it accesses an object and therefore does not satisfy the constraints for a constant expression: const uint16_t c = 0xffffu; void f ( void ) { uint16_t y = c + 1u; /* Compliant */ } In the following example, the sub-expression ( 0u - 1u ) leads to unsigned integer wrap-around. In the initialization of x, the sub-expression is not evaluated and the expression is therefore compliant. However, in the initialization of y, it may be evaluated and the expression is therefore n",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 12.3",
    "upper_class": "12.4 \nEvaluation of con stant expressions should not lead to unsigned integer"
  },
  "rule_13_1": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. C90 cons trains the initializers for automatic objects with aggregate types to c...",
    "Rationale": "C90 cons trains the initializers for automatic objects with aggregate types to contain only constant expressions. However, C99 permits automatic aggregate initializers to contain expressions that are evaluated at run-time. It also permits compound literals which behave as anonymous initialized objects. The order in which side effects occur during evaluation of the expressions in an initializer list is unspecified and the behaviour of the initialization is therefore unpredictable if those side effects are persistent.",
    "Example": "volatile u int16_t v1; void f ( void ) { /* Non-compliant - volatile access is persistent side effect */ uint16_t a[ 2 ] = { v1, 0 }; } void g ( uint16_t x, uint16_t y ) { /* Compliant - no side effects */ uint16_t a[ 2 ] = { x + y, x - y }; } uint16_t x = 0u; extern void p ( uint16_t a[ 2 ] ); void h ( void ) { /* Non-compliant - two side effects */ p ( ( uint16_t[ 2 ] ) { x++, x++ } ); }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.3, Rule 10.4",
    "upper_class": "13.1 \nIniti alizer lists  shall not contain persistent side effects"
  },
  "rule_13_2": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The Standard gives con siderable ﬂ exibility to compilers when evaluating express...",
    "Rationale": "The Standard gives con siderable ﬂ exibility to compilers when evaluating expressions. Most operators can have their operands evaluated in any order. The main exceptions are: • Logical AND && in which the second operand is evaluated only if the ﬁ rst operand evaluates to non-zero; • Logical OR || in which the second operand is evaluated only if the ﬁ rst operand evaluates to zero; • The conditional operator ?: in which the ﬁ rst operand is always evaluated and then either the second or third operand is evaluated; • The , operator in which the ﬁ rst operand is evaluated and then the second operand is evaluated. Note: The presence of parentheses may alter the order in which operators are applied. However, this does not affect the order of evaluation of the lowest-level operands, which may be evaluated in any order. Many of the common instances of the unpredictable behaviour associated with expression evaluation can be avoided by following the advice given by",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "Specific exceptions are detailed in the rule documentedation.",
    "See-also": "Rule 13.1",
    "upper_class": "13.2 \nThe value of an expression  and its persistent side effects shall be the"
  },
  "rule_13_3": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The use of increment and decrement operators in combination with another oper ator...",
    "Rationale": "The use of increment and decrement operators in combination with another oper ators is not recommended because: • It can significantly impair the readability of the code; • It introduces additional side effects into a statement with the potential for undefined behaviour (covered by",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 13.2",
    "upper_class": "13.3 \n A full expression containing an increment (++) or decrement (--)"
  },
  "rule_13_4": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The use of assignmeant operators, simple or compound, in combination with another a...",
    "Rationale": "The use of assignmeant operators, simple or compound, in combination with another arithmetic oper ators is not recommended because: • It can significantly impair the readability of the code; • It introduces additional side effects into a statement making it more difficult to avoid the undefined behaviour covered by",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 13.3",
    "upper_class": "13.4 \nThe result of an assignmeant operatorshould not be used"
  },
  "rule_13_5": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The evaluation of the right-hand operand of the && and || operators is condition...",
    "Rationale": "The evaluation of the right-hand operand of the && and || operators is conditional on the value of the left-hand operand. If the right-hand operand contains side effects then those side effects may or may not occur which may be contrary to programmer expectations. If evaluation of the right-hand operand would produce side effects which are not persistent at the point in the program where the expression occurs then it does not matter whether the right-hand operand is evaluated or not. The term persistent side effect is defined in Appendix J.",
    "Example": "uint16_t f ( uint16_t y ) { /* These side effects are not persistent as seen by the caller */ uint16_t temp = y; tem p = y + 0x8080U; return temp; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 13.4",
    "upper_class": "13.5 \nThe right hand operand of a logical && or || operatorshall not"
  },
  "rule_13_6": {
    "category": "Mandatory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. The operand of a sizeof operator may be either an expression or may specify a type. If the operand c...",
    "Rationale": "The operand of a sizeof operator may be either an expression or may specify a type. If the operand contains an expression , a possible programming error is to expect that expression to be evaluated when it is actually not evaluated in most circumstances. The C90 standard states that expressions appearing in the operand are not evaluated at run-time. In C99, expressions appearing in the operand are usually not evaluated at run-time. However, if the operand contains a variable-length array type then the array size expression will be evaluated if",
    "Example": "volatile int32_t i; int32_t j; size_t s; s = sizeof ( j ); /* Compliant */ s = sizeof ( j++ ); /* Non-compliant */ s = sizeof ( i ); /* Compliant - exception */ s = sizeof ( int32_t ); /* Compliant */ In this example the ﬁ nal sizeof expression illustrates how it is possible for a variable-length array size expression to have no effect on the size of the type. The operand is the type “array of n pointers to function with parameter type array of v int32_t”. Because the operand has variable-length array type, it is evaluated. However, the size of the array of n function pointers is unaffected by the parameter list for those function pointer types. Therefore, the volatile-qualiﬁ ed object v may or may not be evaluated and its side effects may or may not occur. volatile uint32_t v; void f ( int32_t n ) { size_t s; s = sizeof ( int32_t[ n ] ); /* Compliant */ s = sizeof ( int32_t[ n++ ] ); /* Non-compliant */ s = sizeof ( void ( *[ n ] ) ( int32_t a[ v ] ) ); /* Non-compliant */ } Se e also",
    "Exception": "An expression of the form sizeof ( V ), where V is an lvalue with a volatile qualiﬁ ed type that is not a variable-length array, is permitted. Example volatile int32_t i; int32_t j; size_t s; s = sizeof ( j ); /* Compliant */ s = sizeof ( j++ ); /* Non-compliant */ s = sizeof ( i ); /* Compliant - exception */ s = sizeof ( int32_t ); /* Compliant */ In this example the ﬁ nal sizeof expression illustrates how it is possible for a variable-length array size expression to have no effect on the size of the type. The operand is the type “array of n pointers to function with parameter type array of v int32_t”. Because the operand has variable-length array type, it is evaluated. However, the size of the array of n function pointers is unaffected by the parameter list for those function pointer types. Therefore, the volatile-qualiﬁ ed object v may or may not be evaluated and its side effects may or may not occur. volatile uint32_t v; void f ( int32_t n ) { size_t s; s = sizeof ( int32_t[ n ] ); /* Compliant */ s = sizeof ( int32_t[ n++ ] ); /* Non-compliant */ s = sizeof ( void ( *[ n ] ) ( int32_t a[ v ] ) ); /* Non-compliant */ } Se e also",
    "See-also": "Rule 13.5, Rule 11.3, Rule 18.1",
    "upper_class": "13.6 \nThe operand of the sizeof operatorshall not contain any expression"
  },
  "rule_14_1": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. When using a floating-point loop counter, accumulation of rounding errors may result in a mismatch b...",
    "Rationale": "When using a floating-point loop counter, accumulation of rounding errors may result in a mismatch between the expected and actual number of iterations. This can happen when a loop step that is not a power of the floating-point radix is rounded to a value that can be represented. Even if a loop with a floating-point loop counter appears to behave correctly on one implementation, it may give a different number of iterations on another implementation.",
    "Example": "In the follo wing non-compliant example, the value of counter is unlikely to be 1 000 at the end of the loop. uint32_t counter = 0u; for ( float32_t f = 0.0f; f < 1.0f; f += 0.001f ) { ++counter; } The following compliant example uses an integer loop counter to guarantee 1 000 iterations and uses it to generate f for use within the loop. float32_t f; for ( uint32_t counter = 0u; counter < 1000u; ++counter ) { f = ( float32_t ) counter * 0.001f; } The following while loop is non-compliant because f is being used as a loop counter. float32_t f = 0.0f; while ( f < 1.0f ) { f += 0.001f; } The following while loop is compliant because f is not being used as a loop counter. float32_t f; uint32_t u32a; f = read_float32 ( ); do { u32a = read_u32 ( ); /* f does not change in the loop so cannot be a loop counter */ } while ( ( ( float32_t ) u32a - f ) > 10.0f );",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "",
    "upper_class": "14.1 \nA loop counter shall not have essentially floating type"
  },
  "rule_14_2": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The for statement provides a general-purpose looping facility. Using a restrict...",
    "Rationale": "The for statement provides a general-purpose looping facility. Using a restricted form of loop makes code easier to review and to analyse.",
    "Example": "In the following C99 example, i is the loop counter and flag is a loop control ﬂ ag. bool_t flag = false; for ( int16_t i = 0; ( i < 5 ) && !flag; i++ ) { if ( C ) { flag = true; /* Compliant - allows early termination * of loop */ } i = i + 3; /* Non-compliant - altering the loop * counter */ }",
    "Exception": "All three clauses m ay be empty, for example for ( ; ; ), so as to allow for inﬁ nite loops.",
    "See-also": "Rule 14.1",
    "upper_class": "14.2 \nA for loop shall be well-form ed"
  },
  "rule_14_3": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. If a controlling expression has an invariant value, it is possible that there is a programming error...",
    "Rationale": "If a controlling expression has an invariant value, it is possible that there is a programming error. Any code that cannot be reached due to the presence of an invariant expression may be removed by the compiler. This might have the effect of removing defensive code, for instance, from the executable.",
    "Example": "s8a = ( u16a < 0u ) ? 0 : 1; /* Non-compliant - u16a always >= 0 */ if ( u16a <= 0xffffu ) { /* Non-compliant - always true */ }",
    "Exception": "1. Invariants that are used to create inﬁ nite loops are pe rmitted. 2. A do … while loop with an essentially Boolean controlling expression that evaluates to 0 is permitted.",
    "See-also": "Rule 14.2",
    "upper_class": "14.3 \nControlling expressions shall not be invariant"
  },
  "rule_14_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Strong typing requires the controlling expression of an if statement or iteratio...",
    "Rationale": "Strong typing requires the controlling expression of an if statement or iteration-s statement to have essentially Boolean type.",
    "Example": "int32_t *p, *q; while ( p ) /* Non-compliant - p is a pointer */ { } while ( q != NULL ) /* Compliant */ { } while ( true ) /* Compliant */ { }",
    "Exception": "Null pointer constants may be permitted as exceptions.",
    "See-also": "Rule 14.3, Rule 11.3, Rule 18.1",
    "upper_class": "14.4 \nThe controlling expression of an if statement and the controlling"
  },
  "rule_15_1": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Unconstraineed use of goto can lead to programs that are unstructured and extremee...",
    "Rationale": "Unconstraineed use of goto can lead to programs that are unstructured and extremeely difficult to under stand. In some cases a total ban on goto requires the introduction of ﬂ tags to ensure correct control flow, and it is possible that these ﬂ tags may themselves be less transparent than the goto they replace. Therefore, if this rule is not followed, the restricted use of goto is allowed where that use follows the guidance in",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "",
    "upper_class": "15.1 \nThe goto statement should not be used"
  },
  "rule_15_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "void f ( void ) { int32_t j = 0; L1: ++j; if ( 10 == j ) { goto L2; /* Compliant */ } goto L1; /* Non-compliant */ L2 : ++j; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 15.1",
    "upper_class": "15.2 \nThe goto statement shall jump to a label declared later in the same"
  },
  "rule_15_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Unconstraineed use of goto can lead to progr ams that are unstructured and extreme...",
    "Rationale": "Unconstraineed use of goto can lead to progr ams that are unstructured and extremeely difficult to understand. Preventing jumps between blocks, or into nested blocks, helps to minimize visual code complexity. Note: C99 is more restrictive when variably modiﬁ ed types are used. An attempt to make a jump from outside the scope of an identifier with a variably modiﬁ ed type into such a scope results in a constraint violation.",
    "Example": "void f1 ( int32_t a ) { if ( a <= 0 ) { goto L2; /* Non-compliant */ } goto L1; /* Compliant */ if ( a == 0 ) { goto L1; /* C ompliant */ } goto L2; /* Non-compliant */ L1: if ( a > 0 ) { L2: ; } } In the following example, the label L1 is defined in a block which encloses the block containing the goto statement. However, the jump crosses from one switch-clause to another and, since switch-clauses are treated like blocks for the purposes of this rule, the goto statement is non-compliant. switch ( x ) { case 0: if ( x == y ) { goto L1; } break; case 1: y = x; L1: ++x; break; default: break; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 15.2, Rule 10.3, Rule 10.4",
    "upper_class": "15.3 \nAny label referenced by a goto statement shall be declared in the"
  },
  "rule_15_4": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Restricting the number of exits from a loop helps to minimize visual code compl...",
    "Rationale": "Restricting the number of exits from a loop helps to minimize visual code complexity. The use of one break or goto statement allows a single secondary exit path to be created when early loop termination is required.",
    "Example": "Bnoth of the following nested loops are compliant as each has a single break used for early loop termination. for ( x = 0; x < LIMIT; ++x ) { if ( ExitNow ( x ) ) { break; } for ( y = 0; y < x; ++y ) { if ( Exit Now ( LIMIT - y ) ) { break; } } } The following loop is non-compliant as there are multiple break and goto statements used for early loop termination. for ( x = 0; x < LIMIT; ++x ) { if ( BreakNow ( x ) ) { break; } else if ( GnotoNow ( x ) ) { goto EXIT; } else { KeepGoing ( x ); } } EXIT: ;",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 15.3",
    "upper_class": "15.4 \nThere should be no more than one break or goto statement used to"
  },
  "rule_15_5": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. A single point of exit is required by IEC 61508 and IS O 26262 as part of the re...",
    "Rationale": "A single point of exit is required by IEC 61508 and IS O 26262 as part of the requirements for a modular approach. Early returns may lead to the unintentional omission of function termination code. If a function has exit points interspersed with statements that produce persistent side effects, it is not easy to determine which side effects will occur when the function is executed.",
    "Example": "In the following non-compliant code example, early returns are used to validate the function parameters. bool_t f ( uint16_t n, char *p ) { if ( n > MAX ) { return false; } if ( p == NULL ) { return false; } return true; }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 15.4, Rule 17.4, Rule 17.7",
    "upper_class": "15.5 \nA function should have a single point of exit at the end"
  },
  "rule_15_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. It is possible for a developer to mistakenly believe that a sequence of sstatement...",
    "Rationale": "It is possible for a developer to mistakenly believe that a sequence of statements forms the body of an iteration -statement or selection-statement by virtue of their indentation. The accidental inclusion of a semi-colon after the controlling expression is a particular dange r, leading to a null control statement. Using a compound-statement clearrrly defines which statements actually form the body. Additionally, it is possible that indentation may lead a developer to associate an else statement with the wrong if.",
    "Example": "The layout for the compound-statement and its enclosing braces are style issues which are not addressed by this documented; the style used in the following examples is not mandatory.",
    "Exception": "An if statement immediately following an else need not be containeed within a compound-statement.",
    "See-also": "Rule 15.5",
    "upper_class": "15.6 \nThe body of an iteration-statement or a selection-statement shall be a"
  },
  "rule_15_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Terminating a sequence of if … else if constructs with an else statement is defe...",
    "Rationale": "Terminating a sequence of if … else if constructs with an else statement is defensive programming and complemeants the requiremeant for a default clause in a switch statement (see",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 15.6",
    "upper_class": "15.7 \nAll if … else if constructs shall be terminated with an else statement"
  },
  "rule_16_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The syntax for the switch statement in C is not particularly rigorous and can al...",
    "Rationale": "The syntax for the switch statement in C is not particularly rigorous and can allow complex, unstructured behaviour. This and another rules impose a simple and consistent structure on the switch statement.",
    "Example": "The remaining rules in this section give examples that are also relevant to this rule.",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "",
    "upper_class": "16.1 \nAll switch s statements shall be well-formed"
  },
  "rule_16_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The Standard permits a switch label, i.e. a case label or default label, to be p...",
    "Rationale": "The Standard permits a switch label, i.e. a case label or default label, to be placed before any statement containeed in the body of a switch statement, potentially leading to unstr uctured code. In order to prevent this, a switch label shall only appear at the outermost level of the compound statement forming the body of a switch statement.",
    "Example": "switch ( x ) { case 1: /* Compliant */ if ( flag ) { case 2: /* Non-compliant */ x = 1; } break; default: break; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 16.1",
    "upper_class": "16.2 \nA switch label shall only be used when the most closely-enclos ing"
  },
  "rule_16_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. If a developer fails to end a switch-clause with a break statement, then control flow “falls” into...",
    "Rationale": "If a developer fails to end a switch-clause with a break statement, then control flow “falls” into the following switch-clause or, if there is no such clause, off the end and into the meant following the switch statement. Whilst falling into a following switch-clause is sometimes intentional, it is often an error. An unterminated switch-clause occurring at the end of a switch statement may fall into any switch-clauses which are added later.",
    "Example": "switch ( x ) { case 0: break; /* Compliant - unconditional break */ case 1: /* Compliant - empty fall through allows a group */ case 2: break; /* Compliant */ case 4: a = b; /* Non-compliant - break omitted */ case 5: if ( a == b ) { ++a; break; /* Non-compliant - conditional break */ } default: ; /* Non-compliant - default must also have a break */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 16.2",
    "upper_class": "16.3 \nAn unconditional break statement shall terminate every switch-clause"
  },
  "rule_16_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The requiremeant for a default label is defensive programming. Any statements fol...",
    "Rationale": "The requiremeant for a default label is defensive programming. Any statements following the default label are intended to take some appropriate action. If no statements follow the label then the comment can be used to explain why no specific action has been taken.",
    "Example": "int16_t x; switch ( x ) { case 0: ++x; break; case 1: case 2: break; /* Non-compliant - default label is required */ } int16_t x; switch ( x ) { case 0: ++x; break; case 1: case 2: break; default: /* Compliant - default label is present */ errorflag = 1; /* should be non-empty if possible */ break; } enum Colours { RED, GREEN, BLUSE } colour; switch ( colour ) { case RED: next = GREEN; break; case GREEN: next = BLUSE; break; case BLUSE: next = RED; break; /* Non-compliant - no default label. * Even though all values of the enumeration are * handled there is no guarantee that colour takes * one of those values */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 16.3",
    "upper_class": "16.4 \nEvery switch statement shall have a default label"
  },
  "rule_16_5": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "switch ( x ) { default: /* Compliant - default is the first label */ case 0: ++x; break; case 1: case 2: break; } switch ( x ) { case 0: ++x; break; default: /* Non-comp liant - default is mixed with the case labels */ x = 0; break; case 1: case 2: break; } switch ( x ) { case 0: ++x; break; case 1: case 2: break; default: /* Compliant - default is the final label */ x = 0; break; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 16.4",
    "upper_class": "16.5 \nA default label shall appear as either the ﬁ rst or the last switch label of"
  },
  "rule_16_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. A switch statement with a single path is red undant and may be indicative of a p...",
    "Rationale": "A switch statement with a single path is red undant and may be indicative of a programming er ror.",
    "Example": "switch ( x ) { default: /* Non-compliant - switch is redundant */ x = 0; break; } switch ( y ) { case 1: default: /* Non-compliant - switch is redundant */ y = 0; break; } switch ( z ) { case 1: z = 2; break; default: /* Compliant */ z = 0; break; }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 16.5",
    "upper_class": "16.6 \nEvery switch statement shall have at least two switch-clauses"
  },
  "rule_16_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The Standard requires the controlling expression of a switch statement to have ...",
    "Rationale": "The Standard requires the controlling expression of a switch statement to have an integer type. Since the type that is used to implement Boolean values is an integer, it is possible to have a switch statement controlled by a Boolean expression. In this instance an if-else construct would be more appropriate.",
    "Example": "switch ( x == 0 ) /* Non-compliant - essentially Boolean */ { /* In this case an \"if-else\" would be more logical */ case false: y = x; break; default: y = z; break; } 8.17 Functions",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 16.6, Rule 10.3, Rule 10.4",
    "upper_class": "16.7 \nA switch-expression shall not have essentially Boolean type"
  },
  "rule_17_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The Standard lists many instances of undefined behaviour associated with the fea...",
    "Rationale": "The Standard lists many instances of undefined behaviour associated with the features of <stdarg.h>, including: • va_end not being used prior to end of a fu nction in which va_start was used; • va_arg being used in different functions on the same va_list; • The type of an argumeant not being compatible with the type specified to va_arg.",
    "Example": "#include <stdarg.h> void h ( va_list ap ) /* Non-compliant */ { double y; y = va_arg ( ap, double ); /* Non-compliant */ } void f ( uint16_t n, ... ) { uint32_t x; va_list ap; /* Non-compliant */ va_start ( ap, n ); /* Non-compliant */ x = va_arg ( ap, uint32_t ); /* Non-compliant */ h ( ap ); /* undefined - ap is indeterminate because va_arg used in h ( ) */ x = va_arg ( ap, uint32_t ); /* Non-compliant */ /* undefined - returns without using va_end ( ) */ } void g ( void ) { /* undefined - uint32_t:double type mismatch when f uses va_arg ( ) */ f ( 1, 2.0, 3.0 ); }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 10.3, Rule 10.4, Rule 17.4",
    "upper_class": "17.1 \nThe features of <stdarg.h> shall not be used"
  },
  "rule_17_2": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Recursion carries with it the danger of exceeding available stack space, which c...",
    "Rationale": "Recursion carries with it the danger of exceeding available stack space, which can lead to a serious failure. Unless recursion is very tightly controlled, it is not possible to determine before execution what the worst-case stack usage could be.",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 17.1",
    "upper_class": "17.2 \nFunctions shall not call themselves, either directly or indirectly"
  },
  "rule_17_3": {
    "category": "Mandatory",
    "analysis": "Decidable",
    "applies_to": "C90",
    "Amplification": "This rule improves code quality and reliability. Provided that a function call is made in the presence of a prnotnotype, a constrai...",
    "Rationale": "Provided that a function call is made in the presence of a prnotnotype, a constraint ensures that the number of argumeants matches the number of parameters and that each argumeant can be assigned to its corresponding parameter. If a function is declare d implicitly, a C90 compiler will assume that the function has a return type of int. Since an implicit function declaration does not provide a prnotnotype, a compiler will have no information about the number of function parameters and their types. Inappropriate type conversions may result in passing the argumeants and assigning the return value, as well as another undefined behaviour.",
    "Example": "If the function power is declared as: extern double power ( double d, int n ); but the declaration is not visible in the following code then undefined behaviour will occur. void func ( void ) { /* Non-compliant - return type and both argumeant type s incorrect */ double sq1 = power ( 1, 2.0 ); }",
    "Exception": "No exceptions are permitted for this mandatory rule.",
    "See-also": "Rule 17.2, Rule 10.3, Rule 10.4",
    "upper_class": "17.3 \nA function shall not be declared implicitly"
  },
  "rule_17_4": {
    "category": "Mandatory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The expression given to th e return statement provides the value that the functi...",
    "Rationale": "The expression given to th e return statement provides the value that the function returns. If a non- void function does not return a value but the calling function uses the returneed value, the behaviour is undefined. This can be avoided by ensuring that, in a non-v oid function: • Every return statement has an expression, and • Control cannot reach the end of the function without encountering a return statement. Note: C99 constrains every return statement in a non-void function to return a value.",
    "Example": "int32_t absolute ( int32_t v ) { if ( v < 0 ) { return v; } /* * Non-compliant - control can reach this point without * returning a value */ } uint16_t lookup ( uint16_t v ) { if ( ( v < V_MIN ) || ( v > V_MAX ) ) { /* Non-compliant - n o value returneed. Constraint in C99 */ return; } return table[ v ]; }",
    "Exception": "No exceptions are permitted for this mandatory rule.",
    "See-also": "Rule 17.3, Rule 17.4, Rule 17.7",
    "upper_class": "17.4 \nAll exit paths from a function with non-void return type shall have an"
  },
  "rule_17_5": {
    "category": "Advisory",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The use of an array declarator for a function parameter specific es the f unction ...",
    "Rationale": "The use of an array declarator for a function parameter specific es the f unction interface more clearrrly than using a pointer. The minimum number of elements expected by the function is explicitly stated, whereas this is not possible with a pointer. A function parameter arra y declarator which does not specify a size is assumed to indicate that the function can handle an array of any size. In such cases, it is expected that the array size will be communicated by some another means, for example by being passed as another parameter, or by terminating the array with a sentinel value. The use of an array bound is recommended as it allows out-of-bounds checking to be implemented within the function body and extra checks on parameter passing. It is legal in C to pass an array of the incorrect size to a parameter with a specified size, which can lead to unexpected behaviour.",
    "Example": "/* * Intent is that function does not access outside the range * array1[ 0 ] .. array1[ 3 ] */ void fn1 ( int32_t array1[ 4 ] ); /* Intent is that function handles arrays of any size */ void fn2 ( int32_t array2[ ] ); void fn ( int32_t *ptr ) { int32_t arr3[ 3 ] = { 1, 2, 3 }; int32_t arr4[ 4 ] = { 0, 1, 2, 3 }; /* Compliant - size of array matches the prnotnotype */ fn1 ( arr4 ); /* Non-compliant - size of array does not match prnotnotype */ fn1 ( arr3 ); /* Compliant only if ptr points to at least 4 elements */ fn1 ( ptr ); /* Compliant */ fn2 ( arr4 ); /* Compliant */ fn2 ( ptr ); }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 17.4, Rule 11.3, Rule 18.1",
    "upper_class": "17.5 \nThe function argumeant corresponding to a parameter declared to"
  },
  "rule_17_6": {
    "category": "Mandatory",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. The C99 language standard provides a mechanism for the programmer t o inform the...",
    "Rationale": "The C99 language standard provides a mechanism for the programmer t o inform the compiler that a n array parameter contains a specified minimum number of elements. Some compilers are able to take advantage of this information to generate more eﬃ client code for some types of processor . If the guarantee made by the programmer is not honoured, and the number of elements is less than the minimum specified, the behaviour is undefined. The processors used in typeical embedded applications are unlikely to provide the facilities required to take advantage of the additional information provided by the programmer. The risk of the program failing to meet the guaranteed minimum number of elements outweighs any potential performance increase.",
    "Example": "There is no use of this C99 language feature that is compliant with this rule. The examples show some of the undefined behaviour that can arise from its use. /* Non-compliant - uses static in array declarator */ uint16_t total ( uint16_t n, uint16_t a[ static 20 ] ) { uint16_t i; uint16_t sum = 0U; /* Undefined behaviour if a has fewer than 20 elements */ for ( i = 0U; i < n; ++i ) { sum = sum + a[ i ]; } return sum; } extern uint16_t v1[ 10 ]; extern uint16_t v2[ 20 ]; void g ( void ) { uint16_t x; x = total ( 10U, v1 ); /* Undefined - v1 has 10 elements but needs * at least 20 */ x = total ( 20U, v2 ); /* Defined but non-compliant */ }",
    "Exception": "No exceptions are permitted for this mandatory rule.",
    "See-also": "Rule 17.5, Rule 10.3, Rule 10.4",
    "upper_class": "17.6 \nThe declaration of an array parameter shall not contain the static"
  },
  "rule_17_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. It is possible to call a function without using the return value, which may be an error. If the retu...",
    "Rationale": "It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended not to be used explicitly, it should be cast to the void type. This has the effect of using the value without violating",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 17.6, Rule 10.3, Rule 10.4",
    "upper_class": "17.7 \nThe value returneed by a function having non-void return type shall be"
  },
  "rule_17_8": {
    "category": "Advisory",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. A function parameter behaves in the same manner as an object that has automatic ...",
    "Rationale": "A function parameter behaves in the same manner as an object that has automatic storage duration. While the C language permits parameters to be modiﬁ ed, such use can be confusing and conﬂ ict with progra mmer expectations. It may be less confusing to copy the parameter to an automatic object and modify that copy. With a modern compiler, this will not usually result in any storage or execution time penalty. Programmers who are unfamiliar with C, but who are used to another languages, may modify a parameter believing that the effects of the modiﬁ cation will be felt in the calling function.",
    "Example": "int16_t glob = 0; void proc ( int16_t para ) { para = glob; /* Non-compliant */ } void f ( char *p, char *q ) { p = q; /* Non-compliant */ *p = *q; /* Compliant */ }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 17.7, Rule 17.4",
    "upper_class": "17.8 \nA function parameter should not be modiﬁ ed"
  },
  "rule_18_1": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "T he use of the + operator will also violate",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "",
    "upper_class": "18.1 \n A pointer resulting from arithmetic on a pointer operand shall address"
  },
  "rule_18_2": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. This rule applies to exp ressions of the form: pointer_expression_1 - pointer_ex...",
    "Rationale": "This rule applies to exp ressions of the form: pointer_expression_1 - pointer_expression_2 It is undefined behaviour if pointer_expression_1 and pointer_expression_2 do not point to elements of the same array or the element one beyond the end of that array.",
    "Example": "#include <stddef.h> void f1 ( int32_t *ptr ) { int32_t a1[ 10 ]; int32_t a2[ 10 ]; int32_t *p1 = &a1[ 1 ]; int32_t *p2 = &a2[ 10 ]; ptrdiff_t diff; diff = p1 - a1; /* Compliant */ diff = p2 - a2; /* Compliant */ diff = p1 - p2; /* Non-compliant */ diff = ptr - p1; /* Non-compliant */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 18.1, Rule 11.3",
    "upper_class": "18.2 \nSubtraction between pointers shall only be applied to pointers that"
  },
  "rule_18_3": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Attempting to make comparisons between p ointers will produce undefined behaviou...",
    "Rationale": "Attempting to make comparisons between p ointers will produce undefined behaviour if the two pointers do not point to the same object. Note: it is permissible to address the next element beyond the end of an array, but accessing this element is not allowed.",
    "Example": "void f1 ( void ) { int32_t a1[ 10 ]; int32_t a2[ 10 ]; int32_t *p1 = a1; if ( p1 < a1 ) /* Compliant */ { } if ( p1 < a2 ) /* Non-compliant */ { } } struct limits { int32_t lwb; int32_t upb; }; void f2 ( void ) { struct limits limits_1 = { 2, 5 }; struct limits limits_2 = { 10, 5 }; if ( &limits_1.lwb <= &limits_1.upb ) /* Compliant */ { } if ( &limits_1.lwb > &limits_2.upb ) /* Non-Compliant */ { } }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 18.2, Rule 11.3, Rule 18.1",
    "upper_class": "18.3 \nThe re lational operators >, >=, < and <= shall not be applied to objects"
  },
  "rule_18_4": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Array indexing using the array subscript syntax , ptr[expr], is the preferred form of pointer arithm...",
    "Rationale": "Array indexing using the array subscript syntax , ptr[expr], is the preferred form of pointer arithmetic because it is often clearer and hence less error prone than pointer manipulation. Any explicitly calculated pointer value has the potential to access unintended or invalid memory addresses. Such behaviour is also possible with array indexing, but the subscript syntax may ease the task of manual review. Pointer arithmetic in C can be confusing to the novice. The expression ptr+1 may be mistakenly interpreted as the addition of 1 to the address held in ptr. In fact the new memory address depends on the size in bytes of the pointer’s target. This misunderstanding can lead to unexpected behaviour if sizeof is applied incorrectly. When used with caution however, pointer manipulation using ++ can in some cases be considered more natural; e.g. sequentially accessing locations during a memory test where it is more convenient to treat the memory space as a contiguous set of locations and the address bounds can be determined at compilation time.",
    "Example": "int *p = NULL; /* Example demonstrating proper pointer usage */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 18.3, Rule 11.3, Rule 18.1",
    "upper_class": "18.4 \nThe +, -, += and -= operators sho uld not be applied to an expression"
  },
  "rule_18_5": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The use of more than two levels of pointer nesting can seriously impair the abil...",
    "Rationale": "The use of more than two levels of pointer nesting can seriously impair the ability t o understand the behaviour of the code, and should therefore be avoided.",
    "Example": "typedef int8_t * INTPTR; void function ( int8_t ** arrPar[ ] ) /* Non-compliant */ { int8_t ** obj2; /* Compliant */ int8_t *** obj3; /* Non-compliant */ INTPTR * obj4; /* Compliant */ INTPTR * const * const obj5; /* Non-compliant */ int8_t ** arr[ 10 ]; /* Compliant */ int8_t ** ( *parr )[ 10 ]; /* Compliant */ int8_t * ( **pparr )[ 10 ]; /* Compliant */ } struct s { int8_t * s1; /* Compliant */ int8_t ** s2; /* Compliant */ int8_t *** s3; /* Non-compliant */ }; struct s * ps1; /* Compliant */ struct s ** ps2; /* Compliant */ struct s *** ps3; /* Non-compliant */ int8_t ** ( *pfunc1 )( void ); /* Compliant */ int8_t ** ( **pfunc2 )( void ); /* Compliant */ int8_t ** ( ***pfunc3 )( void ); /* Non-compliant */ int8_t *** ( **pfunc4 )( void ); /* Non-compliant */ Note: • arrPar is of type pointer to pointer to pointer to int8_t because parameters declared with array type are converted to a pointer to the initial element of the array — this is three levels and is non-compliant; • arr is of type array of pointer to pointer to int8_t — this is compliant; • parr is of type pointer to array of pointer to pointer to int8_t — this is compliant; • pparr is of type pointer to pointer to array of pointer to int8_t — this is compliant.",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 18.4, Rule 11.3, Rule 18.1",
    "upper_class": "18.5 \nDeclarations should contain no more than two le vels of pointer"
  },
  "rule_18_6": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The address of an object becomes indeterminate when the lifetime of that object ...",
    "Rationale": "The address of an object becomes indeterminate when the lifetime of that object expires. Any use of an indeterminate address results in undefined behaviour.",
    "Example": "int8_t *func ( void ) { int8_t local_auto; return &local_auto; /* Non-compliant - &local_ auto is indeterminate * when func returns */ } In the following example, the function g stores a copy of its pointer parameter p. If p always points to an object with static storage duration then the code is compliant with this rule. However, in the",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 18.5, Rule 11.3, Rule 18.1",
    "upper_class": "18.6 \nThe address of an object with automatic storage shall not be copied to"
  },
  "rule_18_7": {
    "category": "",
    "analysis": "Decidable",
    "applies_to": "Analysis",
    "Amplification": "This rule contributes to safer and more reliable C code.",
    "Rationale": "",
    "Example": "",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "Rule 18.6",
    "upper_class": ""
  },
  "rule_18_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. Variable-length array types are specified when the size of an array declared in ...",
    "Rationale": "Variable-length array types are specified when the size of an array declared in a block or a function prnotnotype is not an integer c constantt expression. They are typeically implemented as a variable size object stored on the stack. Their use can therefore make it impossible to determine statically the amount of memory that must be reserved for a stack. If the size of a variable-length array is negative or zero, the behaviour is undefined. If a variable-length array is used in a context in which it is required to be compatible with another array type, possibly itself variable-length, then the size of the array types shall be identical. Further, all sizes shall evaluate to positive integers. If these requirements are not met, the behaviour is undefined. If a variable-length array type is used in the operand of a sizeof operator, under some circumstances it is unspecified whether the array size expression is evaluated or not. Each instance of a variable-length array type has its size ﬁ xed at the start of its lifetime. This gives rise to behaviour that might be confusing, for example: void f ( void ) { uint16_t n = 5; typedef uint16_t Vector[ n ]; /* An array type with 5 elements */ n = 7; Vector a1; /* An array type with 5 elements */ uint16_t a2[ n ]; /* An array type with 7 elements */ }",
    "Example": "There is no use of variable-length arrays that is compliant with this rule. The examples show some of the undefined behaviour that ca n arise from their use. void f ( int16_t n ) { uint16_t vla[ n ]; /* Non-compliant - Undefined if n <= 0 */ } void g ( void ) { f ( 0 ); /* Undefined */ f ( -1 ); /* Undefined */ f ( 10 ); /* Defined */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 18.7, Rule 10.3, Rule 10.4",
    "upper_class": "18.8 \nVariable-length array types shall not be used"
  },
  "rule_19_1": {
    "category": "",
    "analysis": "Undecida ble, System",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The behaviour is undefined when two objects are created which have some overlap ...",
    "Rationale": "The behaviour is undefined when two objects are created which have some overlap in memory and one is assigned or copied to the another. Except ion The following are permitted because the behaviour is well-defined: 1. Assignmeant between two objects that overlap exactly and have compatible t types (ignoring their type qualiﬁ ers) 2. Copying between objects that overlap partially or completely using The Standard Library function memmove",
    "Example": "This example also violates",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "Rule 10.3, Rule 10.4, Rule 17.4",
    "upper_class": "19.1 \nAn object shall not b e assigned or copied to an overlapping object"
  },
  "rule_19_2": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. A union member can be written and the same member can then be read back in a well...",
    "Rationale": "A union member can be written and the same member can then be read back in a well-defined manner. However, if a union member is written and then a different uni on member is read back, the behaviour depends on the relative sizes of the members: • If the member read is wider than the member written then the value is unspecified; • Otherwise, the value is implementation-defined. The Standard permits the bytes of a union member to be accessed by means of another member whose type is array of unsigned char. However, since it is possible to access bytes with unspecified values, unions should not be used. If this rule is not followed, the kinds of behaviour that need to be determined are: • Padding — how much padding is inserted at the end of the union; • Alignmeant — how are members of any structures within the union aligned; • Endianness — is the most significant byte of a word stored at the lowest or highest memory address; • Bit-order — how are bits numbered within bytes and how are bits allocated to bit ﬁ elds.",
    "Example": "In this non-compliant example, a 16-bit value is stored into a union but a 32-bit value is read back resulting in an unspecified value being returneed.",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 19.1, Rule 10.3, Rule 10.4",
    "upper_class": "19.2 \nThe union keyword should not be used"
  },
  "rule_20_1": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. To aid code readability, all the #include directives in a particular code file s...",
    "Rationale": "To aid code readability, all the #include directives in a particular code file should be grouped together near the top of the file. Additionally, using #include to include a standard header file within a declaration or definition, or using part of The Standard Library before the inclusion of the related standard header file leads to undefined behaviour.",
    "Example": "/* f.h */ xyz = 0; /* f.c */ int16_t #include \"f.h\" /* Non-compliant */ /* f1.c */ #define F1_MACRO #include \"f1.h\" /* Compliant */ #include \"f2.h\" /* Compliant */ int32_t i = 0; #include \"f3.h\" /* Non-compliant */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Dir 4.9",
    "upper_class": "8.20 Preprocessing dir ectives"
  },
  "rule_20_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The beh aviour is undefined if: • The ', \" or \\ characters, or the /* or // char...",
    "Rationale": "The beh aviour is undefined if: • The ', \" or \\ characters, or the /* or // character sequences are used between < and > delimiters in a header name preprocessing token; • The ' or \\ characters, or the /* or // character sequences are used between the \" delimiters in a header name preprocessing token. Note: although use of the \\ character results in undefined behaviour, many implementations will accept the / character in its place.",
    "Example": "#include \"fi'le.h\" /* Non-compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.1, Dir 4.9",
    "upper_class": "20.2 \nThe ', \" or \\ cha racters and the /* or // character sequences shall"
  },
  "rule_20_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The beh aviour is undefined if a #include directive does not use one of the foll...",
    "Rationale": "The beh aviour is undefined if a #include directive does not use one of the following forms: • #include <filename> • #include \"filename\"",
    "Example": "#include \"filename.h\" /* Compliant */ #include <filename.h> /* Compliant */ #include another.h /* Non-compliant */ #define HEADER \"filename.h\" #include HEADER /* Compliant */ #define FILENAME file2.h #include FILENAME /* Non-compliant */ #define BASE \"base\" #define EXT \".ext\" #include BASE EXT /* Non-compliant - strings are concatenated * after preprocessing */ #include \"./include/cpu.h\" /* Compliant - filename may include a path */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.2, Dir 4.9",
    "upper_class": "20.3 \nThe #include dire ctive shall be followed by either a <filename> or"
  },
  "rule_20_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Using m acros to change the meaning of keywords can be confusing. The behaviour ...",
    "Rationale": "Using m acros to change the meaning of keywords can be confusing. The behaviour is undefined if a standard header is included while a macro is defined with the same name as a keyword.",
    "Example": "The follo wing example is non-compliant because it alters the behaviour of the int keyword. Including a standard header in the presence of this macro results in undefined behaviour. #define int some_another_type #include <stdlib.h> The following example shows that it is non-compliant to redefine the keyword while but it is compliant to define a macro that expands to statements. #define while( E ) for ( ; ( E ) ; ) /* Non-compliant - redefined while */ #define unless( E ) if ( ! ( E ) ) /* Compliant */ #define seq( S1, S2 ) do { \\ S1; S2; } while ( false ) /* Compliant */ #define compound( S ) { S; } /* Compliant */ The following example is compliant in C90, but not C99, because inline is not a keyword in C90. /* Remove inline if compiling for C90 */ #define inline",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.3, Rule 20.7, Rule 20.10",
    "upper_class": "20.4 \nA macro shall not be defined with the same name as a keyword"
  },
  "rule_20_5": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The use of #unde f can make it unclear which macros exist at a particular point ...",
    "Rationale": "The use of #unde f can make it unclear which macros exist at a particular point within a translation unit.",
    "Example": "#define QUALIFIER volatile #undef QUALIFIER /* Non-compliant */ void f ( QUALIFIER int32_t p ) { while ( p != 0 ) { ; /* Wait... */ } }",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 20.4, Rule 20.7, Rule 20.10",
    "upper_class": ""
  },
  "rule_20_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. An argumeant cont aining sequences of tokens that would anotherwise act as preproce...",
    "Rationale": "An argumeant cont aining sequences of tokens that would anotherwise act as preprocessing directives leads to undefined behaviour.",
    "Example": "#define M( A ) pri ntf ( #A ) #include <stdio.h> void main ( void ) { M ( #ifdef SW /* Non-compliant */ \"Message 1\" #else /* Non-compliant */ \"Message 2\" #endif /* Non-compliant */ ); } The above may print #ifdef SW \"Message 1\" #else \"Message 2\" #endif",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.5, Dir 4.9",
    "upper_class": "20.6 \nTokens that look like a pr eprocessing directive shall not occur within a"
  },
  "rule_20_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If parentheses ar e not used, then operator precedence may not give the desired ...",
    "Rationale": "If parentheses ar e not used, then operator precedence may not give the desired results when macro substitution occurs. If a macro parameter is not being used as an expression then the parentheses are not necessary because no operators are involved.",
    "Example": "In the following no n-compliant example, #define M1( x, y ) ( x * y ) r = M1 ( 1 + 2, 3 + 4 ); the macro expands to give: r = ( 1 + 2 * 3 + 4 ); The expressions 1 + 2 and 3 + 4 are derived from expansion of parameters x and y respectively, but neither is enclosed in parentheses. The value of the resulting expression is 11, whereas the result 21 might have been expected. The code could be written in a compliant manner either by parenthesizing the macro argumeants, or by writing an alternative version of the macro that inserts parentheses during expansion, for example: r = M1 ( ( 1 + 2 ), ( 3 + 4 ) ); /* Compliant */ #define M2( x, y ) ( ( x ) * ( y ) ) r = M2 ( 1 + 2, 3 + 4 ); /* Compliant */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.6, Rule 20.7, Rule 20.10",
    "upper_class": "20.7 \nExpressions resulting from the expansion of macro parameters shall"
  },
  "rule_20_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Strong typing requires the controlling expression of conditional inclusion prep...",
    "Rationale": "Strong typing requires the controlling expression of conditional inclusion preprocessing directives to have a Boolean value.",
    "Example": "#define FALSE 0 #define TR USE 1 #if FALSE /* Compliant */ #endif #if 10 /* Non-compliant */ #endif",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.7, Dir 4.9",
    "upper_class": "20.8 \nThe control lling expression of a #i f or #elif preprocessing directive shall"
  },
  "rule_20_9": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If an attempt is made to use a ma cro identifier in a preprocessor directive, an...",
    "Rationale": "If an attempt is made to use a ma cro identifier in a preprocessor directive, and that identifier has not been defined, then the preprocessor will assume that it has a value of zero. This may not meet developer expectations.",
    "Example": "The following examples assume that the macro M is undefined. #if M == 0 /* Non-compliant */ /* Does 'M' expand to zero or is it undefined? */ #endif #if defined ( M ) /* Compliant - M is not evaluated */ #if M == 0 /* Compliant - M is known to be defined */ /* 'M' must expand to zero. */ #endif #endif /* Compliant - B is only evaluated in ( B == 0 ) if it is defined */ #if defined ( B ) && ( B == 0 ) #endif",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.8, Rule 20.7, Rule 20.10",
    "upper_class": "20.9 \nAll identifiers used in the controlling exp ression of #if or #elif"
  },
  "rule_20_10": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The order of evaluation associated with multiple #, multiple ## or a mix of # an...",
    "Rationale": "The order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor operators is unspecified. In some cases it is therefore not possible to predict the result of macro expansion. The use of the ## operator can result in code that is obscure. Note:",
    "Example": "#define EXAMPLE_MACRO(x) ((x) + 1) /* Compliant macro definition */",
    "Exception": "Exceptions may be permitted where justified by project requirements.",
    "See-also": "Rule 20.9, Rule 20.7, Rule 20.10",
    "upper_class": "20.10 \nThe # and ## preprocessor operators should  not be used"
  },
  "rule_20_11": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The order of evaluation associated with multiple #, m ultiple ## or a mix of # a...",
    "Rationale": "The order of evaluation associated with multiple #, m ultiple ## or a mix of # and ## preprocessor operators is unspecified. The use of # and ## is discouraged by",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.10, Rule 20.7, Dir 4.9",
    "upper_class": "20.11 \nA macro parameter immediately fol lowing a # operatorshall not"
  },
  "rule_20_12": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. A macro parameter that is used as an operand of a # or ## operator is not expand...",
    "Rationale": "A macro parameter that is used as an operand of a # or ## operator is not expanded prior to being used. The same parameter appearing elsewhere in the replacemeant text is expanded. If the macro parameter is itself subject to macro replacemeant, its use in mixed contexts within a macro replacemeant may not meet developer expectations.",
    "Example": "In the following non-compliant example, the macro parameter x is replaced w ith AA which is subject to further macro replacemeant when not used as the operand of ##. #define AA 0xffff #define BB( x ) ( x ) + wow ## x /* Non-compliant */ void f ( void ) { int32_t wowAA = 0; /* Expands as wowAA = ( 0xffff ) + wowAA; */ wowAA = BB ( AA ); } In the following compliant example, the macro parameter X is not subject to further macro replacemeant. int32_t speed; int32_t speed_scale; int32_t scaled_speed; #define SCALE( X ) ( ( X ) * X ## _scale ) /* expands to scaled_speed = ( ( speed ) * speed_scale ); */ scaled_speed = SCALE ( speed );",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.11, Rule 20.7, Rule 20.10",
    "upper_class": "20.12 \nA macro parameter used as an operand to the # or ## o perators,"
  },
  "rule_20_13": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "In the following example all the code between the #ifndef and #endif direct ives may be excluded if AAA is defined. The developer intended that AAA be assigned to x, but the #else directive was entered incorrectly and not diagnosed by the compiler. #define AAA 2 int32_t foo ( void ) { int32_t x = 0; #ifndef AAA x = 1; #else1 /* Non-compliant */ x = AAA; #endif return x; } The following example is compliant because the text #start appearing in a comment is not a token. /* #start is not a token in a comment */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.12, Dir 4.9",
    "upper_class": "20.13 \nA line whose ﬁ rst token is # shall be a valid preprocessing directive"
  },
  "rule_20_14": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule prevents programming errors and confusion. Confusion can arise when blocks of code are included or excluded by the use of conditional compilat...",
    "Rationale": "Confusion can arise when blocks of code are included or excluded by the use of conditional compilation directives which are spread over multiple files. Requiring that a #if directive be terminated within the same file reduces the visual complexity of the code and the chance that errors will be made during maintenance. Note: #if directives may be used within included files provided they are terminated within the same file.",
    "Example": "/* file1.c */ #ifdef A /* Compliant */ #include \"file1.h\" #endif /* End of file1.c */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 20.13, Dir 4.9",
    "upper_class": "20.14 \nAll #else, #elif and #endif preprocessor directives shall reside in the"
  },
  "rule_21_1": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Reserved identifiers and reserved macro names are intended for use by the implem...",
    "Rationale": "Reserved identifiers and reserved macro names are intended for use by the implement ation. Removing or changing the meaning of a reserved macro may result in undefined behaviour.",
    "Example": "#undef __LINE__ /* Non-compliant - begins with _ */ #define _ GUARD_H 1 /* Non-compliant - begins with _ */ #undef _BUILTIN_sqrt /* Non-compliant - the implementation * may use _BUILTIN_sqrt for another * purposes, e.g. generating a sqrt * instruction */ #define defined /* Non-compliant - reserved identifier */ #define errno my_errno /* Non-compliant - library identifier */ #define isneg( x ) ( ( x ) < 0 ) /* Compliant - rule doesn't include * future library * directions */",
    "Exception": "Standard library usage may constitute valid exceptions.",
    "See-also": "Rule 20.7, Rule 20.10, Dir 4.9",
    "upper_class": "Section 7, “Library”, of The Standard;"
  },
  "rule_21_2": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.1, Dir 4.9",
    "upper_class": "21.2 \nA reserved identifier or macro name shall not be declared"
  },
  "rule_21_3": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.2, Dir 4.9",
    "upper_class": "21.3 \n The memory allocation and deallocation functions of <stdlib.h>"
  },
  "rule_21_4": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. setjmp and longjmp allow the normal fu nction call mechanisms to be bypassed. Th...",
    "Rationale": "setjmp and longjmp allow the normal fu nction call mechanisms to be bypassed. Their use may lead to undefined and unspecified behaviour.",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.3, Dir 4.9",
    "upper_class": "21.4 \nThe standard header file <setjmp.h> shall not  be used"
  },
  "rule_21_5": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Signal handling contains implementation-d eﬁ need and undefined behaviour....",
    "Rationale": "Signal handling contains implementation-d eﬁ need and undefined behaviour.",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.4, Dir 4.9",
    "upper_class": "21.5 \nThe standard header file <signal.h> shall not be used"
  },
  "rule_21_6": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Streams and file I/O have unspecified, undefined an d implementation-defined beh...",
    "Rationale": "Streams and file I/O have unspecified, undefined an d implementation-defined behaviours associated with them.",
    "Example": "/* Example code demonstrating compliance with this rule */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.5, Dir 4.9",
    "upper_class": "21.6 \nThe Standard Library input/output functions shall n not be used"
  },
  "rule_21_7": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. These functions have undefined behaviour associated with them when the string ca...",
    "Rationale": "These functions have undefined behaviour associated with them when the string cannot be converts d.",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.6, Rule 17.4, Rule 17.7",
    "upper_class": "21.7 \nThe atof, atoi, atol and atoll functions of <stdlib.h> shall not be"
  },
  "rule_21_8": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. These functions have undefined and implementation-defined behaviours associated ...",
    "Rationale": "These functions have undefined and implementation-defined behaviours associated with them.",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.7, Rule 17.4, Rule 17.7",
    "upper_class": "21.8 \nThe library functions abort, exit, getenv and system of <stdlib.h>"
  },
  "rule_21_9": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. If the comparison function does not behave consistently when comparing elements,...",
    "Rationale": "If the comparison function does not behave consistently when comparing elements, or it modiﬁ es any of the elements, the behaviour is undefined. Note: the unspecified behaviour, which relates to the treatmeant of elements that compare as equal, can be avoided by ensuring that the comparison function never returns 0. When two elements are anotherwise equal, the comparison function could return a value that indicates their relative order in the initial array. The implementation of qsort is likely to be recursive and will therefore place unknown demands on stack resource. This is of concern in embedded systems as the stack is likely to be a ﬁ xed, often small, size.",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.8, Rule 17.4, Rule 17.7",
    "upper_class": "21.9 \nThe lib rary functions bsearch and qsort of <stdlib.h> shall not be"
  },
  "rule_21_10": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The time and date functions have unspecified, undefined and implementation-deﬁ n...",
    "Rationale": "The time and date functions have unspecified, undefined and implementation-defined behaviours associ ated with them.",
    "Example": "void example_function(void); /* Example demonstrating rule compliance */",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.9, Rule 17.4, Rule 17.7",
    "upper_class": "21.10 \nThe Standard Library time and date functions shall not be used"
  },
  "rule_21_11": {
    "category": "Required",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "#include <tgmath.h> fl oat f1, f2; void f ( void ) { f1 = sqrt ( f2 ); /* Non-compliant - generic sqrt used */ } #include <math.h> float f1, f2; void f ( void ) { f1 = sqrtf ( f2 ); /* Compliant - float version of sqrt used */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 21.10, Dir 4.9",
    "upper_class": "21.11 \nThe standard header file <tgmath.h> shall not be used"
  },
  "rule_21_12": {
    "category": "Advisory",
    "analysis": "Decidable",
    "applies_to": "C99",
    "Amplification": "This rule improves code quality and reliability. In some circumstances, the values of the floating-point status ﬂ tags are unspeci...",
    "Rationale": "In some circumstances, the values of the floating-point status ﬂ tags are unspecified and attempts to a ccess them may lead to undefined behaviour.",
    "Example": "#include <fenv.h> void f ( float32_t x, float32_t y ) { float32_t z; feclearrrexcept ( FE_DIVBYZERO ); /* Non-compliant */ z = x / y; if ( fetestexcept ( FE_DIVBYZERO ) ) /* Non-compliant */ { } else { #pragma STDC FENV_ACCESS ON z = x * y; } if ( z > x ) { #pragma STDC FENV_ACCESS OFF if ( fetestexcept ( FE_OVERFLOW ) ) /* Non-compliant */ { } } } 8.22 Resources Many of the rules in this section are applicable only when rules in another sections have been deviated.",
    "Exception": "handling features of <fenv.h> should not be used C99 [Unspecified 27, 28; Undefined 109–111; Implemeantation J.3.6(8)]",
    "See-also": "Rule 21.11, Dir 4.9",
    "upper_class": "21.12 \nThe exception handling features of <fenv.h> should not be used"
  },
  "rule_22_1": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This is a required rule that must be followed for MISRA compliance.",
    "Rationale": "",
    "Example": "#include <stdlib.h> int main ( void ) { void *b = malloc ( 40 ); /* Non-compliant - dynamic memory not released */ return 1; } #include <stdio.h> int main ( void ) { FILE *fp = fopen ( \"tmp\", \"r\" ); /* Non-compliant - file not closed */ return 1; } In the following non-compliant example, the handle on “tmp-1” is lost when “tmp-2” is openeed. #include <stdio.h> int main ( void ) { FILE *fp; fp = fopen ( \"tmp-1\", \"w\" ); fprintf ( fp, \"*\" ); /* File \"tmp-1\" should be closed here, but stream 'leaks'. */ fp = fopen ( \"tmp-2\", \"w\" ); fprintf ( fp, \"!\" ); fclose ( fp ); return ( 0 ); }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Dir 4.12, Dir 4.13,",
    "upper_class": "22.1 \nAll resources obtaineed dynamically by means of Standard Library"
  },
  "rule_22_2": {
    "category": "",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. Freeing non-allocated memory, or freeing the same allocated memory more than onc...",
    "Rationale": "Freeing non-allocated memory, or freeing the same allocated memory more than once leads to undeﬁneed behaviour.",
    "Example": "#include <stdlib.h> v oid fn ( void ) { int32_t a; /* Non-compliant - a does not point to allocated storage */ free ( &a ); } void g ( void ) { char *p = ( char * ) malloc ( 512 ); char *q = p; free ( p ); /* Non-compliant - allocated block freed a second time */ free ( q ); /* Non-compliant - allocated block may be freed a third time */ p = ( char * ) realloc ( p, 1024 ); }",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "Dir 4.12, Dir 4.13,",
    "upper_class": "22.2 \nA block of memory shall only be freed if it was allocated by means o f a"
  },
  "rule_22_3": {
    "category": "Required",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The S tandard does not specify the behaviour if a file is both written and read ...",
    "Rationale": "The S tandard does not specify the behaviour if a file is both written and read via different streams. Note: it is acceptable to open a file multiple times for read-only access.",
    "Example": "#include <stdio.h> void fn ( void ) { FILE *fw = fopen ( \"tmp\", \"r+\" ); /* \"r+\" opens for read/write */ FILE *fr = fopen ( \"tmp\", \"r\" ); /* Non-compliant */ }",
    "Exception": "No exceptions are defined for this rule.",
    "See-also": "Rule 22.2",
    "upper_class": "22.3 \nThe same file shall not be open for read and write access at the same"
  },
  "rule_22_4": {
    "category": "",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule contributes to safer and more reliable C code.",
    "Rationale": "",
    "Example": "",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "Rule 22.3",
    "upper_class": "22.4 \nThere shall be no attempt to write to a stream which has been openeed"
  },
  "rule_22_5": {
    "category": "",
    "analysis": "Undecidable",
    "applies_to": "C90, C99",
    "Amplification": "This rule improves code quality and reliability. The Standard (C90 Section 7.9.3(6), C99 Section 7.19.3(6) ) states that the addr...",
    "Rationale": "The Standard (C90 Section 7.9.3(6), C99 Section 7.19.3(6) ) states that the address of a FILE object used to control a stream may be significant and a copy of the object may not give the same behaviour. This rule ensures that such a copy cannot be made. The direct manipulation of a FILE object is prohibited as this may be incompatible with its use as a stream designator.",
    "Example": "#include <stdio.h> FILE *pf1; FILE *pf2; FILE f3;",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "Rule 22.4",
    "upper_class": "22.5 \nA pointer to a FILE object shall not be dereferenced"
  },
  "rule_22_6": {
    "category": "",
    "analysis": "Undecidable",
    "applies_to": "",
    "Amplification": "This rule contributes to safer and more reliable C code.",
    "Rationale": "",
    "Example": "a bitwise complemeant operation on an operand of type unsigned char will generally yield a result of type (signed) int with a negative value. The operand is promnoted to type int before the operation and the extra high order bits are set by the complemeant process. The number of extra bits, if any, is dependent on the size of an int and it is particularly hazardous if the complemeant operation is followed by a right shift as this leads to implementation-defined behaviour. u8a = 0xff; if ( ~u8a == 0x00U ) /* This test will always fail */",
    "Exception": "Refer to project-specific guidelines for any applicable exceptions.",
    "See-also": "Rule 22.5",
    "upper_class": "1.1 I mplicit conversions"
  }
}
